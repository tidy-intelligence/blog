import pandas as pd
from pyfixest.estimation import feols
# Chunk 1
library(dplyr)
library(WDI)
library(fixest)
indicators <- c(
"gdp_per_capita" = "NY.GDP.PCAP.KD",  # GDP per capita (constant 2010 US$)
"gov_exp_share" = "SE.XPD.TOTL.GD.ZS",  # Government expenditure on education, total (% of GDP)
"health_exp_share" = "SH.XPD.CHEX.GD.ZS",  # Current health expenditure (% of GDP)
"co2_emissions" = "EN.ATM.CO2E.PC" # CO2 emissions (metric tons per capita)
)
# wdi_data <- WDI(
#   indicators, country = "all", start = 2000, end = 2020, extra = TRUE
# ) |>
#   as_tibble()
#
# fe_model <- feols(gdp_per_capita ~ gov_exp_share + health_exp_share + co2_emissions | country + year, data = wdi_data)
#
# summary(fe_model)
# TODO: figure out why pyfixest does not work on mac...
# import wbdata
import pandas as pd
from pyfixest.estimation import feols
from pyfixest.summarize import etable
# indicators = {
#   "NY.GDP.PCAP.KD": "gdp_per_capita",
#   "SE.XPD.TOTL.GD.ZS": "gov_exp_share",
#   "SH.XPD.CHEX.GD.ZS": "health_exp_share",
#   "EN.ATM.CO2E.PC": "co2_emissions"
# }
#
# wdi_data = wbdata.get_dataframe(
#   indicators, date = ("2010", "2020"), parse_dates = True
# )
#
# wdi_data.describe()
import os
print(os.environ['DYLD_FALLBACK_LIBRARY_PATH'])
os.environ["DYLD_FALLBACK_LIBRARY_PATH"] = ""
print(os.environ['DYLD_FALLBACK_LIBRARY_PATH'])
from pyfixest.estimation import feols
reticulate::repl_python()
reticulate::repl_python()
library(kknn)
#| message: false
#| warning: false
library(tidymodels)
install.packages("recipes")
install.packages("tidymodels")
#| message: false
#| warning: false
library(tidymodels)
library(readr)
library(janitor)
#| message: false
#| warning: false
data_url <- "https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv"
customer_raw <- read_csv(data_url)
customer <- customer_raw |>
clean_names() |>
select(-customer_id) |>
na.omit() |>
mutate(churn = factor(if_else(churn=="Yes", 1L, 0L)),
female = if_else(gender=="Female", 1L, 0L),
senior_citizen = as.integer(senior_citizen)) |>
select(-gender) |>
mutate(
across(c(partner, dependents, phone_service, paperless_billing),
~if_else(. == "Yes", 1L, 0L)),
across(c(multiple_lines, internet_service, online_security, online_backup,
device_protection, tech_support, streaming_tv, streaming_movies,
contract, paperless_billing, payment_method),
~tolower(gsub("[ |\\-]", "_", ., " |\\-", "_")))
)
set.seed(1234)
customer_split <- initial_split(customer, prop = 4/ 5, strata = churn)
customer_folds <- vfold_cv(training(customer_split), v = 5, strata = churn)
customer_recipe <- recipe(churn ~ ., data = training(customer_split)) |>
step_log(c(total_charges)) |>
step_normalize(c(tenure, monthly_charges)) |>
step_dummy(all_nominal(), -all_outcomes(), one_hot = TRUE)
customer_workflow <- workflow() |>
add_recipe(customer_recipe)
library(glmnet)
spec_logistic <- logistic_reg(penalty = 0.0001, mixture = 1) |>
set_engine("glmnet") |>
set_mode("classification")
library(ranger)
spec_random_forest <- rand_forest() |>
set_engine("ranger") |>
set_mode("classification")
library(xgboost)
spec_xgboost <- boost_tree() |>
set_engine("xgboost") |>
set_mode("classification")
library(kknn)
spec_knn <- nearest_neighbor(neighbors = 4) |>
set_engine("kknn") |>
set_mode("classification")
library(torch)
spec_neural_net <- mlp(epochs = 500, hidden_units = 10) |>
set_engine("brulee") |>
set_mode("classification")
torch::install_torch()
# Chunk 1
#| message: false
#| warning: false
library(tidymodels)
library(readr)
library(janitor)
# Chunk 2
#| message: false
#| warning: false
data_url <- "https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv"
customer_raw <- read_csv(data_url)
customer <- customer_raw |>
clean_names() |>
select(-customer_id) |>
na.omit() |>
mutate(churn = factor(if_else(churn=="Yes", 1L, 0L)),
female = if_else(gender=="Female", 1L, 0L),
senior_citizen = as.integer(senior_citizen)) |>
select(-gender) |>
mutate(
across(c(partner, dependents, phone_service, paperless_billing),
~if_else(. == "Yes", 1L, 0L)),
across(c(multiple_lines, internet_service, online_security, online_backup,
device_protection, tech_support, streaming_tv, streaming_movies,
contract, paperless_billing, payment_method),
~tolower(gsub("[ |\\-]", "_", ., " |\\-", "_")))
)
set.seed(1234)
customer_split <- initial_split(customer, prop = 4/ 5, strata = churn)
customer_folds <- vfold_cv(training(customer_split), v = 5, strata = churn)
# Chunk 3
customer_recipe <- recipe(churn ~ ., data = training(customer_split)) |>
step_log(c(total_charges)) |>
step_normalize(c(tenure, monthly_charges)) |>
step_dummy(all_nominal(), -all_outcomes(), one_hot = TRUE)
# Chunk 4
customer_workflow <- workflow() |>
add_recipe(customer_recipe)
# Chunk 5
library(glmnet)
spec_logistic <- logistic_reg(penalty = 0.0001, mixture = 1) |>
set_engine("glmnet") |>
set_mode("classification")
# Chunk 6
library(ranger)
spec_random_forest <- rand_forest() |>
set_engine("ranger") |>
set_mode("classification")
# Chunk 7
library(xgboost)
spec_xgboost <- boost_tree() |>
set_engine("xgboost") |>
set_mode("classification")
# Chunk 8
library(kknn)
spec_knn <- nearest_neighbor(neighbors = 4) |>
set_engine("kknn") |>
set_mode("classification")
library(torch)
library(brulee)
spec_neural_net <- mlp(epochs = 500, hidden_units = 10) |>
set_engine("brulee") |>
set_mode("classification")
create_metrics_training <- function(spec) {
customer_workflow |>
add_model(spec) |>
fit_resamples(
resamples = customer_folds,
metrics = metric_set(recall, precision, accuracy),
control = control_resamples(save_pred = TRUE)
) |>
collect_metrics(summarize = TRUE) |>
mutate(model = attributes(spec)$class[1])
}
metrics_training <- list(
spec_logistic, spec_random_forest, spec_xgboost,
spec_knn, spec_neural_net
) |>
map_df(create_metrics_training)
renv::snapshot()
