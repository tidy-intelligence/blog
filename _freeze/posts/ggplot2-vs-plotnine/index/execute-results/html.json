{
  "hash": "848694f51dd5c2170a1c57514105c39d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy Data Visualization: ggplot2 vs plotnine\"\ndescription: \"A comparison of implementations of the grammar of graphics in R and Python.\"\nmetadata:\n  pagetitle: \"Tidy Data Visualization: ggplot2 vs plotnine\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-01-14\" \nimage: thumbnail.png\nimage-alt: An image of a bright and friendly office setting with two equally sized screens placed centrally. Each screen displays a simple line chart without any text or numbers. The office is very well-lit, giving a warm and inviting ambiance. The decor is colorful and cheerful, with a minimalist design. The two screens are on a sleek, modern desk in the center of the image. The line charts are clear and straightforward. The overall atmosphere of the office is lively and welcoming, with vibrant colors and ample natural light. Created with DALL-E 3.\n---\n\n\nBoth `ggplot2` and `plotnine` are based on Leland Wilkinson's Grammar of Graphics, a set of principles for creating consistent and effective statistical graphics. This means they both use similar syntax and logic for constructing plots, making it relatively easy for users to transition between them. `ggplot2`, developed by Hadley Wickham, is a cornerstone of the R community and integrates seamlessly with other `tidyverse` packages. `plotnine`, on the other hand, is a Python package that attempts to bring `ggplot2` functionality and philosophy to Python users, but it is not part of a larger ecosystem (although it works well with `pandas`, Python's most popular data manipulation package).\n\nBoth packages use a layer-based approach, where a plot is built up by adding components like axes, geoms, stats, and scales. However, `ggplot2` benefits from R’s native support for data frames and its formula notation, which can make its syntax more concise. `plotnine` has to adhere to Python’s syntax rules, in particular referring to columns via strings, which can occasionally lead to more verbose code. As you can see in the examples below, the syntactic differences are miniscule. \n\nThe types of plots that I chose for the comparison heavily draw on the examples given in [R for Data Science](https://r4ds.hadley.nz/data-visualize) - an amazing resource if you want to get started with data visualization. \n\n## Loading packages and data\n\nWe start by loading the main packages of interest and the popular `palmerpenguins` package that exists for both R and Python. We then use the `penguins` data frame as the data to compare all functions and methods below. Note that I drop all rows with missing values because I don't want to get into related messages in this post. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\npenguins <- na.omit(palmerpenguins::penguins)\n```\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom plotnine import *\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins().dropna()\n```\n:::\n\n::: \n\n## A full-blown example\n\nLet's start with an advancved example that combines many different aesthetics at the same time: we plot two columns against each other, use color and shape aesthetics do differentiate species, include separate regression lines for each species, manually set nice labels, and use a theme. Except for the quotation of column names, `plotnine` has exactly the same syntax as `ggplot2` - this is remarkable!\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm, y = bill_depth_mm, \n           color = species, shape = species)) + \n  geom_point() + \n  geom_smooth(method = \"lm\", formula = \"y ~ x\") +\n  labs(x = \"Bill length (mm)\", y = \"Bill Width (mm)\", \n       title = \"Bill Length vs. Bill Width\", \n       subtitle = \"Using geom_point and geom_smooth of the ggplot2 package\",\n       color = \"Species\", shape = \"Species\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, \n        aes(x = \"bill_length_mm\", y = \"bill_depth_mm\", \n            color = \"species\", shape = \"species\"))\n  + geom_point()\n  + geom_smooth(method = \"lm\", formula = \"y ~ x\")\n  + labs(x = \"Bill Length (mm)\", y = \"Bill Width (mm)\", \n         title = \"Bill Length vs. Bill Width\", \n         subtitle = \"Using geom_point and geom_smooth of the plotnine package\",\n         color = \"Species\", shape = \"Species\")\n  + theme_minimal()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=614}\n:::\n:::\n\n::: \n\n## Visualizing Distributions\n\n### A categorical variable\n\nLet's break down the similarity in smaller steps by focussing on simpler examples. If you have a categorical variable and want to compare its relevance in your data, then `geom_bar()` is your friend. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = island)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, \n       aes(x = \"island\"))\n  + geom_bar()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=614}\n:::\n:::\n\n::: \n\n### A numerical variable\n\nIf you have a numerical variable, usually histograms are a good starting point to get a better feeling for the distribution of your data. `geom_histogram()` with options to control bin widths or number of bins is the aesthetic for this task.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm)) +\n  geom_histogram(binwidth = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, \n       aes(x = \"bill_length_mm\"))\n  + geom_histogram(binwidth = 2)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=614}\n:::\n:::\n\n::: \n\nBoth packages also support the `geom_density()` geom to plot density curves, but I personally wouldn't recommend to start with densities because they are estimated curves that might obscure underlying data features. \n\n## Visualizing Relationships\n\n### A numerical and a categorical variable\n\nTo visualize relationships, you need to have at least two columns. If you have a numerical and a categorical variable, then histograms or densities with groups are a good starting point. The next example illustrates the use of `geom_density()`. \n\nNote that `plotnine` still uses the historical `size` option and not the new `linewidth` wording (see this [blog post](https://www.tidyverse.org/blog/2022/11/ggplot2-3-4-0/) here). Maybe this will change in the future, so keep an eye on [this issue](https://github.com/has2k1/plotnine/issues/742) to stay up to date.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(linewidth = 0.75, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, \n       aes(x = \"body_mass_g\", color = \"species\", fill = \"species\"))\n  + geom_density(size = 0.75, alpha = 0.5)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=614}\n:::\n:::\n\n:::\n\n### Two categorical columns\n\nStacked bar plots are a good way to display the relationship between two categorical columns. `geom_bar()` with the `position` argument is your aesthetic of choice for this task. Note that you can easily switch to counts by using `position = \"identity\"` instead of relative frequencies as in the example below. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, aes(x = \"species\", fill = \"island\"))\n  + geom_bar(position = \"fill\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=614}\n:::\n:::\n\n::: \n\n### Two numerical columns\n\nScatter plots and regression lines are definitely the most common approach for visualizing the relationship between two numerical columns. Here, the `size` parameter controls the size of the shapes that you use for the data points. See the first visualization example if you want to see again how to add a regression line.   \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm, y = flipper_length_mm)) +\n  geom_point(size = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, \n        aes(x = \"bill_length_mm\", y = \"flipper_length_mm\"))\n  + geom_point(size = 2)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=614}\n:::\n:::\n\n::: \n\n### Three or more columns\n\nYou can include more information by mapping columns to additional aesthetics. For instance, we can map colors and shapes to species and create separate plots for each island by using facets. Facets are actually a great way to extend your figures, so I highly recommend playing around with them using your own data. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm, y = flipper_length_mm)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(penguins, \n       aes(x = \"bill_length_mm\", y = \"flipper_length_mm\"))\n  + geom_point(aes(color = \"island\", shape = \"island\"))\n  + facet_wrap(\"~species\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1280 x 960)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=614}\n:::\n:::\n\n::: \n\n## Saving Plots\n\nAs a final comparison, let us look at saving plots. Again, the implementations are virtually the same across both packages with the same function name and corresponding options. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_figure <- penguins |> \n  ggplot(aes(x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point()\n\nggsave(penguins_figure, filename = \"penguins-figure.png\",\n       width = 7, height = 5, dpi = 300)\n```\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\npenguins_figure = (\n  ggplot(penguins, \n         aes(x = \"bill_length_mm\", y = \"flipper_length_mm\"))\n  + geom_point()\n)\n\nggsave(penguins_figure, filename = \"penguins-figure.png\",\n       width = 7, height = 5, dpi = 300)\n```\n:::\n\n::: \n\n## Conclusion\n\nIn terms of syntax, `ggplot2` and `plotnine` are remarkably similar, with minor differences primarily due to the differences between R and Python:\n\n- Column references are implemented via strings in Python, while you can use unquoted column names in R due to its support of non-standard evaluation. \n- The layer connector `+` has to come at the end of the line R, not at the start. In Python, it makes more sense to have it at the start because you can comment out code better, but in principle also at the line end is possible. \n\nThe strongest argument in favor of `ggplot2`, however, is its large ecosystem of extension packages (see, for instance, [this repo](https://github.com/erikgahner/awesome-ggplot2) for a collection of links). \n\nIf you want to learn more about, follow [Cédric Scherer](https://www.cedricscherer.com/) and check out his content. For instance, you can find his data visualization workshop notes from `posit::conf(2022)`  [here](https://www.cedricscherer.com/2022/08/09/2-day-workshop-on-graphic-design-with-ggplot2-at-rstudioconf-2022/). [Thomas Lin Pedersen](https://thomaslinpedersen.art/) also does fantastic things with `ggplot2` among them creating generative art with code. \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}