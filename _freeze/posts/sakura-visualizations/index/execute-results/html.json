{
  "hash": "4ab701d21c488c1f8537bf230e4b3898",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Sakura Visualizations\"\ndescription: \"Visualizing first and full cherry blossom bloom dates for Japanese regions using R and Python\"\nmetadata:\n  pagetitle: \"Sakura Visualizations\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-07-05\" \nimage: thumbnail.png\nimage-alt: A beautiful sakura tree in full bloom, covered with vibrant pink cherry blossoms. The tree stands alone in a serene park with green grass and a clear blue sky in the background. Soft petals are falling gently to the ground, creating a picturesque and tranquil scene. The sunlight filters through the blossoms, casting a soft glow around the tree. Created with DALL-E.\ncategories: \n  - R\n  - Python\n  - Visualization\nformat:\n  html: \n    fig-width: 12\n    fig-height: 8\n    fig-dpi: 300\n---\n\n\n\nWhile I was traveling Japan earlier this year, I had the pleasure to experience sakura, the famous Japanese cherry blossoms. These blossoms are highly significant in Japanese culture, symbolizing the transient nature of life due to their brief blooming period. Sakura typically bloom in spring, from late March to early May, depending on the region. The blossoming of cherry trees is celebrated with hanami, a traditional custom of enjoying the beauty of flowers, often involving picnics under the blooming trees. \n\nClimate change is causing sakura to bloom earlier and for shorter periods due to rising temperatures and shifting phenological patterns. This disrupts traditional hanami festivals, affects pollination success, and leads to regional variations in bloom timing, with urban areas often experiencing more pronounced shifts.\n\nIn this blog post, I visualize data with respect to cherry blossom blooming periods over regions and time. I provide a comprehensive guide on loading and preparing the corresponding data for analysis using both R and Python. The analysis spans from 1953 to 2023, leveraging the `tidyverse` family of packages for R and the `ibis-framework` for Python, complemented by `plotnine` for visualizations. I draw some inspiration from [this blog post](https://yuriko-schumacher.github.io/statistical-analysis-of-cherry-blossom-first-bloom-date/) by Yuriko Schuhmacher. My primary focus is to transform and merge datasets detailing the first and full bloom dates of cherry blossoms and visualizing them by region.\n\n## Loading packages and data\n\nFor the R version, I rely on the `tidyverse` family of packages and list the required packages explicitly. For the Python version, I use `ibis-framework` for data manipulation (see my post on [dplyr-vs-ibis](../dplyr-vs-ibis/index.qmd) for more information) and `plotnine` for visualizations. \n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readr)\nlibrary(lubridate)\nlibrary(ggplot2)\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport ibis\nfrom ibis import _\nimport ibis.selectors as s\nfrom plotnine import *\n```\n:::\n\n\n:::\n\n## Download and prepare data\n\nI use regional cherry blossom data between 1953 and 2023 from the Japan Meteorological Agency provided on [Kaggle](https://www.kaggle.com/datasets/ryanglasnapp/japanese-cherry-blossom-data). There are two data sets: one table provides the dates when the cherry blossoms start blooming and the second table contains the dates when cherry blossoms reach full bloom. In the code below, I combine both to a long format table with additional columns that indicate the day of the year with full bloom and the days between first and full bloom, respectively. \n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsakura_first_bloom_dates <- read_csv(\"data/sakura_first_bloom_dates.csv\") \nsakura_full_bloom_dates <- read_csv(\"data/sakura_full_bloom_dates.csv\")\n  \nfirst_bloom_long <- sakura_first_bloom_dates |>\n  select(-`30 Year Average 1981-2010`, -Notes) |>\n  rename(location = `Site Name`, is_currently_observed = `Currently Being Observed`) |>\n  pivot_longer(`1953`:`2023`, names_to = \"year\", values_to = \"first_bloom\")\n\nfull_bloom_long <- sakura_full_bloom_dates |>\n  select(-`30 Year Average 1981-2010`, -Notes) |>\n  rename(location = `Site Name`, is_currently_observed = `Currently Being Observed`) |>\n  pivot_longer(`1953`:`2023`, names_to = \"year\", values_to = \"full_bloom\")\n\nsakura_dates <- first_bloom_long |>\n  full_join(full_bloom_long, c(\"location\", \"year\", \"is_currently_observed\")) |>\n  mutate(year = as.integer(year),\n         days_to_full_bloom = as.integer(full_bloom - as.Date(paste(year, \"-01-01\", sep = \"\"))),\n         days_from_first_to_full_bloom = as.integer(full_bloom - first_bloom))\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsakura_first_bloom_dates = ibis.read_csv(\"data/sakura_first_bloom_dates.csv\")\nsakura_full_bloom_dates = ibis.read_csv(\"data/sakura_full_bloom_dates.csv\")\n\nfirst_bloom_long = (sakura_first_bloom_dates\n  .drop(\"30 Year Average 1981-2010\", \"Notes\")\n  .rename(location = \"Site Name\", is_currently_observed = \"Currently Being Observed\")\n  .pivot_longer(s.r[\"1953\":\"2023\"], names_to = \"year\", values_to = \"first_bloom\")\n)\n\nfull_bloom_long = (sakura_full_bloom_dates\n  .drop(\"30 Year Average 1981-2010\", \"Notes\")\n  .rename(location = \"Site Name\", is_currently_observed = \"Currently Being Observed\")\n  .pivot_longer(s.r[\"1953\":\"2023\"], names_to = \"year\", values_to = \"full_bloom\")\n)\n\nsakura_dates = (first_bloom_long.outer_join(full_bloom_long, [\"location\", \"year\", \"is_currently_observed\"])\n  .select(~s.contains(\"_right\"))\n  .mutate(year = _.year.cast(\"int32\"))\n  .mutate(days_to_full_bloom = (_.full_bloom - ibis.date(_.year.cast('string') + '-01-01')).cast('interval(\"D\")').cast(\"int32\"),\n          days_from_first_to_full_bloom=(_.full_bloom - _.first_bloom).cast('interval(\"D\")').cast(\"int32\")\n    )\n)\n```\n:::\n\n\n:::\n\nI next add regions that I later use to group the locations. I used a list of regions from [Wikipedia](https://en.wikipedia.org/wiki/List_of_regions_of_Japan) as input and let ChatGPT label the locations accordingly. You can find the resulting mapping on [GitHub](https://github.com/tidy-intelligence/blog/tree/main/posts/sakura-visualizations/data).\n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocations_regions <- read_csv(\"data/locations_region.csv\") \n\nsouthern_islands <- c(\"Naze\", \"Ishigaki Island\", \"Miyakojima\", \"Naha\", \"Minami Daito Island\")\n\nlocations_regions <- locations_regions |> \n  mutate(region = if_else(location %in% southern_islands, \"Ryukyu Islands\", region))\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlocations_regions = ibis.read_csv(\"data/locations_region.csv\")\n\nsouthern_islands = [\"Naze\", \"Ishigaki Island\", \"Miyakojima\", \"Naha\", \"Minami Daito Island\"]\n\nlocations_regions = (locations_regions\n  .mutate(\n    region = ibis.case().when(_.location.isin(southern_islands), \"Ryukyu Islands\").else_(_.region).end()\n  )\n)\n```\n:::\n\n\n:::\n\nBefore we move on to visualizations, let's add the regions to the sakura dates and keep only regions that are still currently observed and with valid full bloom days and days between first and full bloom. In addition, I drop year 1953 to have exactly 70 years of data. Finally, I want to order the regions from north to south. \n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsakura_data <- sakura_dates |> \n  left_join(locations_regions, join_by(location)) |> \n  filter(is_currently_observed == TRUE &\n          year >= 1954 &\n          !is.na(days_to_full_bloom) & \n          !is.na(days_from_first_to_full_bloom))\n\nsakura_data <- sakura_data |> \n  mutate(region = factor(region, levels = c(\"Hokkaidō\", \"Honshū\", \"Kyūshū\", \"Shikoku\", \"Ryukyu Islands\")))\n```\n:::\n\n\n### Python\n\nSince `ibis-framework` does not support factor variables, we have to use `pandas` here.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsakura_data = (sakura_dates\n  .left_join(locations_regions, \"location\")\n  .filter([_.is_currently_observed == True, \n           _.year >= 1954, \n           _.days_to_full_bloom.notnull(),\n           _.days_from_first_to_full_bloom.notnull()])\n)\n\nimport pandas as pd\nsakura_data = sakura_data.to_pandas()\nsakura_data[\"region\"] = pd.Categorical(sakura_data[\"region\"], categories = [\"Hokkaidō\", \"Honshū\", \"Kyūshū\", \"Shikoku\", \"Ryukyu Islands\"], ordered = True)\n```\n:::\n\n\n:::\n\n## Set theme and color scheme\n\nI set the theme and colors for the figures below on a global level. Note that setting the figure size in the theme works best for `plotnine`, while `ggplot2` uses the paramters defined in the YAML header of the `.qmd` file underlying this post. \n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_classic(base_size = 16, base_family = \"SF Pro\")) \n\ntheme_update(\n  panel.grid.minor = element_blank(),\n  panel.grid.major = element_blank(),\n  strip.text = element_text(size = 16),\n  strip.background = element_blank(),\n  axis.title.x = element_blank(), \n  axis.title.y = element_blank(),\n  axis.ticks = element_blank(),\n  axis.line = element_blank()\n)\n\ncolors <- c(\"#ffb7c5\", \"#A0522D\")\nbreaks_year <- seq(1950, 2030, by = 20)\n```\n:::\n\n\n### Python\n\nSince `plotnine` is built on `matplotlib`, setting the font family can be done more flexibly and consistently using the latter's font manager. \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport matplotlib.pyplot as plt\nimport matplotlib.font_manager as fm\n\nfpath = \"/Library/Fonts/SF-Pro.ttf\"\n\nfm.fontManager.addfont(fpath)\nprop = fm.FontProperties(fname = fpath)\nfont_name = prop.get_name()\nplt.rcParams[\"font.family\"] = font_name\n\ntheme_set(theme_classic(base_size = 16) + theme(figure_size = (12, 8)))\n\ntheme_update(\n  panel_grid_minor = element_blank(),\n  panel_grid_major = element_blank(),\n  strip_text = element_text(size = 16),\n  strip_background = element_blank(),\n  axis_title_x = element_blank(),\n  axis_title_y = element_blank(),\n  axis_ticks = element_blank(),\n  axis_line = element_blank()\n)\n\ncolors = [\"#ffb7c5\", \"#A0522D\"]\nbreaks_year = range(1950, 2031, 20)\n```\n:::\n\n\n:::\n\n## Days to full bloom\n\nThe first figure visually represents the full bloom days of cherry blossoms across various regions in Japan over time. Each point on the plot shows the bloom day for a specific year. The line indicates the general trend over time. The regions are separated into individual panels arranged in a single row, allowing for easy comparison. The subtitle highlights a key finding: cities in the northern regions, such as Hokkaidō and Honshū, tend to have earlier bloom dates compared to those in the Ryukyu Islands, which experience later blooms.\n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsakura_data |> \n  ggplot(aes(x = year, y = days_to_full_bloom)) +\n  geom_point(color = colors[1], alpha = 0.9, size = 4, shape = 21, fill = \"white\") +\n  geom_smooth(method = \"loess\", se = FALSE,\n              color = colors[2], linewidth = 2) +\n  facet_wrap(~region, nrow = 1) + \n  labs(title = \"Day of the year with peak cherry tree blossom for regions in Japan since 1954\",\n       subtitle = \"Cities in northern regions Hokkaidō and Honshū exhibit earlier full blooms, while Ryukyu Islands even later\",\n       x = NULL, y = NULL) +\n  scale_x_continuous(breaks = breaks_year) +\n  scale_y_continuous(breaks = seq(30, 150, by = 30))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=3600}\n:::\n:::\n\n\n\n### Python\n\nNote that `linewidth` is still `size` in plotnine.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(sakura_data, \n         aes(x = \"year\", y = \"days_to_full_bloom\"))\n  + geom_point(color = colors[0], alpha = 0.9, size = 4, shape = \"o\", fill = \"white\")\n  + geom_smooth(method = \"loess\", se = False,\n                color = colors[1], size = 2)\n  + facet_wrap(\"~region\", nrow = 1)\n  + labs(title = \"Day of the year with peak cherry tree blossom for regions in Japan since 1954\",\n         subtitle = \"Cities in northern regions Hokkaidō and Honshū exhibit earlier full blooms, while Ryukyu Islands even later\",\n         x = None, y = None)\n  + scale_x_continuous(breaks = breaks_year)\n  + scale_y_continuous(breaks = range(30, 151, 30))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1200 x 800)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=1152}\n:::\n:::\n\n\n:::\n\n## Days from first to full bloom\n\nThe next figure illustrates the duration between the initial opening of cherry blossoms and their peak bloom across different regions in Japan over time. Each point represents the number of days for a given year. The linear line highlights the overall trends in blooming duration. The regions are individually faceted in a single row, enabling side-by-side comparisons. The figure shows that Hokkaidō has the shortest and decreasing periods between blossom opening and peak bloom, while regions like Kyūshū and Ryukyu exhibit increasing durations.\n\n::: {.panel-tabset}\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsakura_data |>\n  ggplot(aes(x = year, y = days_from_first_to_full_bloom)) +\n  geom_point(color = colors[1], alpha = 0.9, size = 4, shape = 21, fill = \"white\") +\n  geom_smooth(method = \"loess\", se = FALSE,\n              color = colors[2], linewidth = 2) +\n  facet_wrap(~region, nrow = 1) +\n  labs(title = \"Days from blossoms opening to peak bloom for regions in Japan since 1954\",\n       subtitle = \"Hokkaidō exhibits the shortest and decreasing blooming periods, while Kyūshū's and Ryukyu's have lengthened\",\n       x = NULL, y = NULL) +\n  scale_x_continuous(breaks = breaks_year)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-3.png){width=3600}\n:::\n:::\n\n\n### Python\n\nNote that point shape in `plotnine` are according to `matplotlib.markers`, see the list [here](https://matplotlib.org/stable/api/markers_api.html).\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggplot(sakura_data, \n        aes(x = \"year\", y = \"days_from_first_to_full_bloom\"))\n  + geom_point(color = colors[0], alpha = 0.9, size = 4, shape = \"o\", fill = \"white\")\n  + geom_smooth(method = \"loess\", se = False, \n                color = colors[1], size = 2)\n  + facet_wrap(\"~region\", nrow = 1)\n  + labs(title = \"Days from blossoms opening to peak bloom for regions in Japan since 1954\",\n         subtitle = \"Hokkaidō exhibits the shortest and decreasing blooming periods, while Kyūshū's and Ryukyu's have lengthened\",\n          x = None, y = None)\n  + scale_x_continuous(breaks = breaks_year)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Figure Size: (1200 x 800)>\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=1152}\n:::\n:::\n\n\n:::\n\n## Concluding remarks\n\nThe post includes detailed code snippets for both R and Python, ensuring that readers can follow along regardless of their preferred programming language. I think it is remarkable how similar R and Python syntax can be these days. \n\nIt would be great to include the daily average temperature in each year as an additional variable for the visualizations (e.g. color intensity of point color) to tackle the question of missing variables that explain the changes. However, for the purpose of this post, it seemed to much work to download the regional temperatures using the [unintuitive and restrictive interface](https://www.data.jma.go.jp/risk/obsdl/index.php) of the Japanese Meterological Agency (JMA). If anybody can point me to an alternative data source, I'm happy to include the temperature changes as well!\n\n\n\n```{=html}\n<section id=\"related-articles\">\n   <h2>Related articles</h2>\n    <div class=\"articles-container\">\n      <a href=\"../dplyr-vs-ibis/index.html\" class=\"article\">\n        <div class=\"quarto-grid-item\">\n            <img src=\"../dplyr-vs-ibis/thumbnail.png\">\n            <div class=\"card-body post-contents\">\n               <h5 class=\"no-anchor card-title listing-title\">Tidy Data Manipulation: dplyr vs ibis</h5>\n               <div class=\"card-text listing-description\">A comparison of R's dplyr and Python's ibis data manipulation packages</div>\n            </div>\n        </div>\n        </a>\n        \n        <a href=\"../ggplot2-vs-plotnine/index.html\" class=\"article\">\n        <div class=\"quarto-grid-item\">\n            <img src=\"../ggplot2-vs-plotnine/thumbnail.png\">\n            <div class=\"card-body post-contents\">\n                <h5 class=\"no-anchor card-title listing-title\">Tidy Data Visualization: ggplot2 vs plotnine</h5>\n                <div class=\"card-text listing-description\">A comparison of implementations of the grammar of graphics in R and Python.</div>\n            </div>\n        </div>\n        </a>\n        \n        <a href=\"../interactive-data-visualization-with-r/index.html\" class=\"article\">\n        <div class=\"quarto-grid-item\">\n            <img src=\"../interactive-data-visualization-with-r/thumbnail.png\">\n            <div class=\"card-body post-contents\">\n                <h5 class=\"no-anchor card-title listing-title\">Interactive Data Visualization with R</h5>\n                <div class=\"card-text listing-description\">A comparison of the dynamic visualization packages ggiraph, plotly and highcharter for the programming language R</div>\n            </div>\n        </div>\n        </a>\n    </div>\n</section>\n```",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}