{
  "hash": "1b5a3f24ed692ab3a834397b187246f0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy Data: Tabular Data Storage Comparison\"\ndescription: \"A comparison of popular open-source data storage technologies using R, Python, and Julia.\"\nmetadata:\n  pagetitle: \"Tidy Data: Tabular Data Storage Comparison\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-01-19\" \nimage: thumbnail.png\nimage-alt: A server room with a more subdued and professional atmosphere. It features four different database servers, each representing a distinct tabular data storage technology. The first server has a sleek and efficient design, symbolizing a modern, high-performance database. The second server is sturdy and straightforward, indicative of a traditional, reliable database system. The third server is compact and practical, representing an efficient, resource-conserving database. The fourth is advanced yet unobtrusive, suggesting a sophisticated, AI-powered database. The room has soft lighting, with a focus on functionality and neatness. The overall ambiance is more business-like and less flashy, conveying a sense of serious technology at work. Created with DALL-E 3.\ndraft: true\n---\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.9.2 at location /Applications/Julia-1.9.app/Contents/Resources/julia/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n:::\n\n\n\n# Create example data\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndata <- tibble(\n  character_column = c(\"A\", \"B\", \"C\", \"D\"), \n  date_column = as.Date(c(\"2023-01-01\", \"2023-02-01\", \"2023-03-01\", \"2023-04-01\")),\n  datetime_column = ymd_hms(c(\"2023-01-01 10:00:00\", \"2023-02-01 11:00:00\", \"2023-03-01 12:00:00\", \"2023-04-01 13:00:00\")),\n  numeric_column = c(1.5, 2.5, 3.5, 4.5),\n  integer_column = as.integer(c(1, 2, 3, 4)),\n  logical_column = c(TRUE, FALSE, FALSE, TRUE)\n)\n\nglimpse(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4\nColumns: 6\n$ character_column <chr> \"A\", \"B\", \"C\", \"D\"\n$ date_column      <date> 2023-01-01, 2023-02-01, 2023-03-01, 2023-04-01\n$ datetime_column  <dttm> 2023-01-01 10:00:00, 2023-02-01 11:00:00, 2023-03-01 …\n$ numeric_column   <dbl> 1.5, 2.5, 3.5, 4.5\n$ integer_column   <int> 1, 2, 3, 4\n$ logical_column   <lgl> TRUE, FALSE, FALSE, TRUE\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ndata = pd.DataFrame({\n  \"character_column\": [\"A\", \"B\", \"C\", \"D\"],\n  \"date_column\": pd.to_datetime([\"2023-01-01\", \"2023-02-01\", \"2023-03-01\", \"2023-04-01\"]).date,\n  \"datetime_column\": pd.to_datetime([\"2023-01-01 10:00:00\", \"2023-02-01 11:00:00\", \"2023-03-01 12:00:00\", \"2023-04-01 13:00:00\"]),\n  \"numeric_column\": [1.5, 2.5, 3.5, 4.5],\n  \"integer_column\": [1, 2, 3, 4],\n  \"logical_column\": [True, False, False, True]\n})\n\ndata.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 4 entries, 0 to 3\nData columns (total 6 columns):\n #   Column            Non-Null Count  Dtype         \n---  ------            --------------  -----         \n 0   character_column  4 non-null      object        \n 1   date_column       4 non-null      object        \n 2   datetime_column   4 non-null      datetime64[ns]\n 3   numeric_column    4 non-null      float64       \n 4   integer_column    4 non-null      int64         \n 5   logical_column    4 non-null      bool          \ndtypes: bool(1), datetime64[ns](1), float64(1), int64(1), object(2)\nmemory usage: 292.0+ bytes\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing DataFrames, Dates\n\ndata = DataFrame(\n  character_column = [\"A\", \"B\", \"C\", \"D\"],\n  date_column = Date.([\"2023-01-01\", \"2023-02-01\", \"2023-03-01\", \"2023-04-01\"]),\n  datetime_column = DateTime.([\"2023-01-01T10:00:00\", \"2023-02-01T11:00:00\", \"2023-03-01T12:00:00\", \"2023-04-01T13:00:00\"]),\n  numeric_column = [1.5, 2.5, 3.5, 4.5],\n  integer_column = Int32.([1, 2, 3, 4]),\n  logical_column = [true, false, false, true]\n);\n\nfunction get_column_types(df::DataFrame)\n  return DataFrame(\n    Column_Name = names(df),\n    Column_Type = eltype.(eachcol(df))\n  )\nend;\n\nget_column_types(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6×2 DataFrame\n Row │ Column_Name       Column_Type\n     │ String            DataType\n─────┼───────────────────────────────\n   1 │ character_column  String\n   2 │ date_column       Date\n   3 │ datetime_column   DateTime\n   4 │ numeric_column    Float64\n   5 │ integer_column    Int32\n   6 │ logical_column    Bool\n```\n\n\n:::\n:::\n\n:::\n\n# CSV\n\nSimple, widely supported, and easy to read and write in R, Python, and Julia.\n\nNot efficient for large datasets and doesn't support complex data structures or metadata well.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\nwrite_csv(data, file = \"data_r.csv\")\ndata_csv <- read_csv(\"data_r.csv\")\n\nglimpse(data_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4\nColumns: 6\n$ character_column <chr> \"A\", \"B\", \"C\", \"D\"\n$ date_column      <date> 2023-01-01, 2023-02-01, 2023-03-01, 2023-04-01\n$ datetime_column  <dttm> 2023-01-01 10:00:00, 2023-02-01 11:00:00, 2023-03-01 …\n$ numeric_column   <dbl> 1.5, 2.5, 3.5, 4.5\n$ integer_column   <dbl> 1, 2, 3, 4\n$ logical_column   <lgl> TRUE, FALSE, FALSE, TRUE\n```\n\n\n:::\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\ndata.to_csv(\"data_python.csv\", index = False)\ndata_csv = pd.read_csv(\"data_python.csv\")\n\ndata_csv.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 4 entries, 0 to 3\nData columns (total 6 columns):\n #   Column            Non-Null Count  Dtype  \n---  ------            --------------  -----  \n 0   character_column  4 non-null      object \n 1   date_column       4 non-null      object \n 2   datetime_column   4 non-null      object \n 3   numeric_column    4 non-null      float64\n 4   integer_column    4 non-null      int64  \n 5   logical_column    4 non-null      bool   \ndtypes: bool(1), float64(1), int64(1), object(3)\nmemory usage: 292.0+ bytes\n```\n\n\n:::\n:::\n\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing CSV\n\nCSV.write(\"data_julia.csv\", data);\ndata_csv = CSV.read(\"data_julia.csv\", DataFrame);\n\nget_column_types(data_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6×2 DataFrame\n Row │ Column_Name       Column_Type\n     │ String            DataType\n─────┼───────────────────────────────\n   1 │ character_column  String1\n   2 │ date_column       Date\n   3 │ datetime_column   DateTime\n   4 │ numeric_column    Float64\n   5 │ integer_column    Int64\n   6 │ logical_column    Bool\n```\n\n\n:::\n:::\n\n\n\n:::\n\n# SQLite\n\nLightweight, file-based SQL database. Easy to use and supported by R, Python, and Julia without the need for a separate server.\n\nNot suitable for very large or high-concurrency applications.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RSQLite)\n\ncon_sqlite <- dbConnect(SQLite(), \"data_r.sqlite\")\n\ncopy_to(con_sqlite, data, \"data\", overwrite = TRUE)\ndata_sqlite <- tbl(con_sqlite, \"data\") |> \n  collect()\n\nglimpse(data_sqlite)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4\nColumns: 6\n$ character_column <chr> \"A\", \"B\", \"C\", \"D\"\n$ date_column      <dbl> 19358, 19389, 19417, 19448\n$ datetime_column  <dbl> 1672567200, 1675249200, 1677672000, 1680354000\n$ numeric_column   <dbl> 1.5, 2.5, 3.5, 4.5\n$ integer_column   <int> 1, 2, 3, 4\n$ logical_column   <int> 1, 0, 0, 1\n```\n\n\n:::\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport sqlite3\n\ncon_sqlite = sqlite3.connect(database = \"data_python.sqlite\")\n\ndata.to_sql(\"data\", con_sqlite, if_exists = \"replace\", index = False)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4\n```\n\n\n:::\n\n```{.python .cell-code}\ndata_sqlite = pd.read_sql_query(\"SELECT * FROM data\", con_sqlite)\n\ndata_sqlite.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 4 entries, 0 to 3\nData columns (total 6 columns):\n #   Column            Non-Null Count  Dtype  \n---  ------            --------------  -----  \n 0   character_column  4 non-null      object \n 1   date_column       4 non-null      object \n 2   datetime_column   4 non-null      object \n 3   numeric_column    4 non-null      float64\n 4   integer_column    4 non-null      int64  \n 5   logical_column    4 non-null      int64  \ndtypes: float64(1), int64(2), object(3)\nmemory usage: 320.0+ bytes\n```\n\n\n:::\n:::\n\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing SQLite\n\ncon_sqlite = SQLite.DB(\"data_julia.sqlite\");\n\nSQLite.load!(data, con_sqlite, \"data\", replace = true);\n\ndata_sqlite = DBInterface.execute(con_sqlite, \"SELECT * FROM data\") |> DataFrame;\n\nget_column_types(data_sqlite)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6×2 DataFrame\n Row │ Column_Name       Column_Type\n     │ String            DataType\n─────┼───────────────────────────────\n   1 │ character_column  String\n   2 │ date_column       Date\n   3 │ datetime_column   DateTime\n   4 │ numeric_column    Float64\n   5 │ integer_column    Int64\n   6 │ logical_column    Int64\n```\n\n\n:::\n:::\n\n\n:::\n\n# DuckDB\n\nhttps://r4ds.hadley.nz/databases\n\nDuckDB is an emerging database management system that's gaining attention for its efficiency and ease of use, particularly in the data science community. It's designed to be an OLAP (Online Analytical Processing) database and is especially well-suited for analytical queries on large datasets.\n\nAs a relatively new system, it might not have the same level of community support, tools, and integrations as more established databases.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(duckdb)\n\ncon_duckdb <- dbConnect(duckdb(), \"data_r.duckdb\")\n\ncopy_to(con_duckdb, data, \"data\", overwrite = TRUE)\ndata_duckdb <- tbl(con_duckdb, \"data\") |> \n  collect()\n\nglimpse(data_duckdb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4\nColumns: 6\n$ character_column <chr> \"A\", \"B\", \"C\", \"D\"\n$ date_column      <date> 2023-01-01, 2023-02-01, 2023-03-01, 2023-04-01\n$ datetime_column  <dttm> 2023-01-01 10:00:00, 2023-02-01 11:00:00, 2023-03-01 …\n$ numeric_column   <dbl> 1.5, 2.5, 3.5, 4.5\n$ integer_column   <int> 1, 2, 3, 4\n$ logical_column   <lgl> TRUE, FALSE, FALSE, TRUE\n```\n\n\n:::\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport duckdb\n\ncon_duckdb = duckdb.connect(\"data_r.duckdb\")\n\ndata.to_sql(\"data\", con_duckdb, if_exists = \"replace\", index = False)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n-1\n```\n\n\n:::\n\n```{.python .cell-code}\ndata_duckdb = pd.read_sql_query(\"SELECT * FROM data\", con_duckdb)\n\ndata_duckdb.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 4 entries, 0 to 3\nData columns (total 6 columns):\n #   Column            Non-Null Count  Dtype         \n---  ------            --------------  -----         \n 0   character_column  4 non-null      object        \n 1   date_column       4 non-null      object        \n 2   datetime_column   4 non-null      datetime64[ns]\n 3   numeric_column    4 non-null      float64       \n 4   integer_column    4 non-null      int64         \n 5   logical_column    4 non-null      int64         \ndtypes: datetime64[ns](1), float64(1), int64(2), object(2)\nmemory usage: 320.0+ bytes\n```\n\n\n:::\n:::\n\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing DuckDB\n\ncon_duckdb = DBInterface.connect(DuckDB.DB, \"data_julia.duckdb\");\n\n# ...\n```\n:::\n\n\n:::\n\n# Parquet\n\nhttps://r4ds.hadley.nz/arrow\n\nColumnar storage format, which is great for analytics and large datasets. Offers efficient data compression and encoding schemes.\n\nRequires additional libraries and understanding of its format.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arrow)\n\nwrite_parquet(data, \"data_r.parquet\")\ndata_parquet <- read_parquet(\"data_r.parquet\")\n\nglimpse(data_parquet)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4\nColumns: 6\n$ character_column <chr> \"A\", \"B\", \"C\", \"D\"\n$ date_column      <date> 2023-01-01, 2023-02-01, 2023-03-01, 2023-04-01\n$ datetime_column  <dttm> 2023-01-01 10:00:00, 2023-02-01 11:00:00, 2023-03-01 …\n$ numeric_column   <dbl> 1.5, 2.5, 3.5, 4.5\n$ integer_column   <int> 1, 2, 3, 4\n$ logical_column   <lgl> TRUE, FALSE, FALSE, TRUE\n```\n\n\n:::\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pyarrow.parquet as pq\n\ndata.to_parquet(\"data_python.parquet\")\ndata_parquet = pd.read_parquet(\"data_python.parquet\")\n\ndata_parquet.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 4 entries, 0 to 3\nData columns (total 6 columns):\n #   Column            Non-Null Count  Dtype         \n---  ------            --------------  -----         \n 0   character_column  4 non-null      object        \n 1   date_column       4 non-null      object        \n 2   datetime_column   4 non-null      datetime64[ns]\n 3   numeric_column    4 non-null      float64       \n 4   integer_column    4 non-null      int64         \n 5   logical_column    4 non-null      bool          \ndtypes: bool(1), datetime64[ns](1), float64(1), int64(1), object(2)\nmemory usage: 292.0+ bytes\n```\n\n\n:::\n:::\n\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing Arrow\n\nArrow.write(\"data_julia.parquet\", data);\n\ndata_parquet = Arrow.Table(\"data_julia.parquet\") |> DataFrame;\n\nget_column_types(data_parquet)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6×2 DataFrame\n Row │ Column_Name       Column_Type\n     │ String            DataType\n─────┼───────────────────────────────\n   1 │ character_column  String\n   2 │ date_column       Date\n   3 │ datetime_column   DateTime\n   4 │ numeric_column    Float64\n   5 │ integer_column    Int32\n   6 │ logical_column    Bool\n```\n\n\n:::\n:::\n\n\n:::\n\n# Conclusion\n\n...\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}