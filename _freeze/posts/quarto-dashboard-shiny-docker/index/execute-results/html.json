{
  "hash": "0aba64f7eddf5fe0d04d2a423d5f4330",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Quarto Dashboard with Shiny Server and Docker\"\ndescription: \"Deploy a Quarto dashboard with an R Shiny backend using Shiny Server inside a Docker container\"\nmetadata:\n  pagetitle: \"Quarto Dashboard with Shiny Server and Docker\"\nauthor: \"Christoph Scheuch\"\ndate: \"2025-03-19\" \nimage: thumbnail.png\nimage-alt: A cozy office scene featuring a shiny bluebird and a small whale, both of equal size, sitting at a large wooden desk. Sunlight streams through a large window, casting a warm glow across the room. The office is decorated with lush green plants in terracotta pots and bookshelves filled with colorful books, creating a cheerful and inviting atmosphere. The bird and whale appear to be engaged in a friendly interaction, adding a whimsical touch to the setting. Created with DALL-E.\ncategories: \n  - R\n  - Shiny\n  - Quarto\n---\n\n\n\n[Quarto dashboards](https://quarto.org/docs/dashboards/) provide a seamless way to create interactive web applications using Python, R, Julia, and Observable. While there are convenient hosting solutions such as shinyapps.io, Hugging Face, and Posit Connect, sometimes you need more control over resources—particularly RAM. Hosting on a cloud platform like Google Cloud Run (GCR) allows for more flexibility and cost efficiency. The method outlined in this post should be applicable to other cloud providers as well, so please share your experience in the comments if you deploy it elsewhere! \n\nIn this blog post, I’ll show you how to deploy a Quarto dashboard with an R Shiny backend inside a Docker container, served using [Shiny Server](https://posit.co/products/open-source/shiny-server/). You can find the complete setup in this GitHub [repo](https://github.com/tidy-intelligence/quarto-dashboard-shiny-docker). If you're interested in a Python-based dashboard deployment, feel free to [reach out](https://www.tidy-intelligence.com/)!\n\n## Setting Up the Dashboard\n\nThe foundation of our dashboard is an `index.qmd` file. In this example, we use a demonstration from the Shiny Gallery that illustrates the [k-Means clustering algorithm](https://shiny.posit.co/r/gallery/start-simple/kmeans-example/).\n\nIt is just a simple app without any additional depdencies. You can check out the code [in the repo](https://github.com/tidy-intelligence/quarto-dashboard-shiny-docker/blob/main/index.qmd), I'm not going into details here.\n\nTo preview the dashboard locally, install [Quarto](https://quarto.org/docs/download/), the necessary packages, and use the following command in your R console:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install required packages\ninstall.packages(\"shiny\")\ninstall.packages(\"quarto\")\n\n# Serve the dasboard\nquarto::quarto_serve(\"index.qmd\")\n```\n:::\n\n\n\nThis launches a local server where you can interact with your dashboard. However, this step isn’t required for deployment, as the Docker container will handle rendering automatically.\n\n## Writing the Dockerfile\n\nOur Docker container needs to: (i) install Quarto and its dependencies, (ii) install Shiny Server to serve the dashboard, and (iii) render the `.qmd` file to an HTML format for deployment. \n\nWe start with the [`rocker/shiny`](https://rocker-project.org/images/versioned/shiny.html) base image, which includes R, Shiny Server, and its dependencies. For production applications, you might want to specify the version here. \n\n```\nFROM rocker/shiny\n```\n\nThen, we install additional dependencies required for Quarto:\n\n```\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    pandoc \\\n    curl \\\n    gdebi-core \\\n    && rm -rf /var/lib/apt/lists/*\n```\n\nNext, we install Quarto (you may want to also specify a fixed version for production stability):\n\n```\nRUN curl -LO https://quarto.org/download/latest/quarto-linux-amd64.deb\nRUN gdebi --non-interactive quarto-linux-amd64.deb\n```\n\nWe install the required R packages:\n\n```\nRUN R -e \"install.packages(c('shiny', 'quarto'))\"\n```\n\nWe copy our custom configuration (see below) for the shiny server into the container.\n\n```\nRUN mkdir -p /srv/shiny-server/dashboard && \\\n    chown -R shiny:shiny /srv/shiny-server\nCOPY shiny-server.conf /etc/shiny-server/shiny-server.conf\n```\n\nWe also set additional permissions for server log files:\n\n```\nRUN mkdir -p /var/log/shiny-server && \\\n    chown -R shiny:shiny /var/log/shiny-server\n```\n\nSince Shiny Server does not natively support `.qmd` files, we need to render the dashboard inside the container. If you are interested in why Shiny Server cannot handle the `.qmd` files directly, check out this [pull request](https://github.com/rstudio/shiny-server/pull/531).\n\n```\nCOPY index.qmd /srv/shiny-server/dashboard/index.qmd\nWORKDIR /srv/shiny-server/dashboard/\nRUN quarto render index.qmd\n```\n\nFinally, we switch to the shiny user for enhanced security and start the shiny Server process upon execution.\n\n```\nUSER shiny\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n## Shiny Server Configuration\n\nShiny Server requires a configuration file (`shiny-server.conf`) to specify how the dashboard is served. Below is a minimal setup:\n\n```\nrun_as shiny;\n\nserver {\n  listen 8080;\n\n  location / {\n    site_dir /srv/shiny-server/dashboard;\n    log_dir /var/log/shiny-server;\n  }\n}\n```\n\nThis configuration ensures that:\n\n- The server runs as the `shiny` user.\n- It listens on port `8080` (which is compatible with GCR).\n- It serves the dashboard from `/srv/shiny-server/dashboard` (as specified in the `Dockerfile`).\n\n## Deploying to a Cloud Platform\n\nDeploying this setup to a cloud provider like GCR is straightforward. If you want automatic deployment from a GitHub repository, you can follow Google’s [Cloud Build]((https://cloud.google.com/run/docs/continuous-deployment-with-cloud-build#setup-cd)) setup. Once the repository is updated, GCR automatically builds and deploys the container.\n\n## Conclusion\n\nWith this setup, you can deploy a Quarto dashboard backed by an R Shiny application in a Docker container, making it easy to run both locally and on cloud platforms like GCR. This approach provides greater flexibility and control over resource allocation compared to managed services.\n\nI’d love to hear your feedback! If you deploy this setup on other platforms, let me know how it works for you in the comments.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}