{
  "hash": "5d4061c8d7bab24012299bcdd0da93f7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy Data Visualization: ggplot2 vs seaborn\"\ndescription: \"A comparison of implementations of the grammar of graphics in R and Python.\"\nmetadata:\n  pagetitle: \"Tidy Data Visualization: ggplot2 vs seaborn\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-01-16\" \nimage: thumbnail.png\nimage-alt: A bright and friendly office setting with two equally sized screens placed centrally on a desk. Each screen displays a simple line chart without any text or numbers. The desk is placed directly on a beach, with no walls or windows, allowing an unobstructed view of the sea and some seagulls in the background. The scene conveys a peaceful and productive atmosphere, with natural beach scenery surrounding the workspace. Created with DALL-E 3.\n---\n\n\n`ggplot2` is based on Leland Wilkinson\"s Grammar of Graphics, a set of principles for creating consistent and effective statistical graphics, and was developed by Hadley Wickham. The package is a cornerstone of the R community and integrates seamlessly with other `tidyverse` packages. \n\n`seaborn`, on the other hand, is a Python package that ...\n\nThe types of plots that I chose for the comparison heavily draw on the examples given in [R for Data Science](https://r4ds.hadley.nz/data-visualize) - an amazing resource if you want to get started with data visualization. \n\n## Loading packages and data\n\nWe start by loading the main packages of interest and the popular `penguins` data that comes with `seaborn` and exists as an R package. We then use the `penguins` data frame as the data to compare all functions and methods below. Note that I drop all rows with missing values because I don\"t want to get into related messages in this post. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\npenguins <- na.omit(palmerpenguins::penguins)\n```\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport seaborn as sns\n\npenguins = sns.load_dataset(\"penguins\")\n\nsns.set_theme(style=\"whitegrid\")\n```\n:::\n\n::: \n\n## A full-blown example\n\nLet\"s start with an advancved example that combines many different aesthetics at the same time: we plot two columns against each other, use color and shape aesthetics do differentiate species, include separate regression lines for each species, manually set nice labels, and use a theme. Except for the quotation of column names, `seaborn` has exactly the same syntax as `ggplot2` - this is remarkable!\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm, y = bill_depth_mm, \n           color = species, shape = species)) + \n  geom_point() + \n  geom_smooth(method = \"lm\", formula = \"y ~ x\") +\n  labs(x = \"Bill length (mm)\", y = \"Bill width (mm)\", \n       title = \"Bill length vs. bill width\", \n       subtitle = \"Using geom_point and geom_smooth of the ggplot2 package\",\n       color = \"Species\", shape = \"Species\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n# TODO: add legend title?\n(sns.lmplot(\n    data=penguins,\n    x = \"bill_length_mm\", y = \"bill_depth_mm\", \n    hue = \"species\", markers = [\"o\", \"s\", \"^\"], fit_reg = True, scatter_kws = {\"s\": 50}\n  )\n  .set_axis_labels(\"Bill length (mm)\", \"Bill width (mm)\")\n  .fig.suptitle(\"Bill length vs. bill width\")\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=596}\n:::\n:::\n\n::: \n\n## Visualizing Distributions\n\n### A categorical variable\n\nLet\"s break down the similarity in smaller steps by focussing on simpler examples. If you have a categorical variable and want to compare its relevance in your data, then `geom_bar()` is your friend. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = island)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nsns.countplot(\n  data=penguins, \n  x=\"island\",\n  order=penguins[\"island\"].value_counts().index\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: \n\n### A numerical variable\n\nIf you have a numerical variable, usually histograms are a good starting point to get a better feeling for the distribution of your data. `geom_histogram()` with options to control bin widths or number of bins is the aesthetic for this task.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm)) +\n  geom_histogram(binwidth = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nsns.histplot(\n  data = penguins, \n  x = \"bill_length_mm\", \n  binwidth = 2\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: \n\nBoth packages also support the `geom_density()` geom to plot density curves, but I personally wouldn\"t recommend to start with densities because they are estimated curves that might obscure underlying data features. \n\n## Visualizing Relationships\n\n### A numerical and a categorical variable\n\nTo visualize relationships, you need to have at least two columns. If you have a numerical and a categorical variable, then histograms or densities with groups are a good starting point. The next example illustrates the use of `geom_density()`. \n\nNote that `seaborn` still uses the historical `size` option and not the new `linewidth` wording (see this [blog post](https://www.tidyverse.org/blog/2022/11/ggplot2-3-4-0/) here). Maybe this will change in the future, so keep an eye on [this issue](https://github.com/has2k1/seaborn/issues/742) to stay up to date.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(linewidth = 0.75, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nsns.kdeplot(\n  data = penguins, \n  x = \"body_mass_g\", \n  hue = \"species\", \n  fill = True, common_norm = False, alpha = 0.5, linewidth = 0.75\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n:::\n\n### Two categorical columns\n\nStacked bar plots are a good way to display the relationship between two categorical columns. `geom_bar()` with the `position` argument is your aesthetic of choice for this task. Note that you can easily switch to counts by using `position = \"identity\"` instead of relative frequencies as in the example below. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nsns.histplot(\n  data = penguins, \n  x = \"species\", \n  hue = \"island\", multiple = \"fill\", stat = \"percent\", shrink = .8\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: \n\n### Two numerical columns\n\nScatter plots and regression lines are definitely the most common approach for visualizing the relationship between two numerical columns. Here, the `size` parameter controls the size of the shapes that you use for the data points. See the first visualization example if you want to see again how to add a regression line.   \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm, y = flipper_length_mm)) +\n  geom_point(size = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nsns.scatterplot(\n  data = penguins, \n  x = \"bill_length_mm\", y = \"flipper_length_mm\", \n  size = 50\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: \n\n### Three or more columns\n\nYou can include more information by mapping columns to additional aesthetics. For instance, we can map colors and shapes to species and create separate plots for each island by using facets. Facets are actually a great way to extend your figures, so I highly recommend playing around with them using your own data. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, \n       aes(x = bill_length_mm, y = flipper_length_mm)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-3.png){width=2100}\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(sns.FacetGrid(data = penguins, col=\"island\", hue=\"species\", margin_titles=True)\n  .map(sns.scatterplot, \"bill_length_mm\", \"flipper_length_mm\", alpha = .7)\n  .add_legend()\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=161}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){width=980}\n:::\n:::\n\n::: \n\n## Saving Plots\n\nAs a final comparison, let us look at saving plots. Again, the implementations are virtually the same across both packages with the same function name and corresponding options. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_figure <- penguins |> \n  ggplot(aes(x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point()\n\nggsave(penguins_figure, filename = \"penguins-figure.png\",\n       width = 7, height = 5, dpi = 300)\n```\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\npenguins_figure = sns.scatterplot(\n  data = penguins, \n  x = \"bill_length_mm\", y = \"flipper_length_mm\"\n)\npenguins_figure.figure.set_size_inches(7, 5)\npenguins_figure.figure.savefig(\"penguins-figure.png\", dpi = 300)\n```\n:::\n\n::: \n\n## Conclusion\n\nIn terms of syntax, `ggplot2` and `seaborn` are considerably different. `ggplot2` follows the basic syntax of \n```markdown\nggplot(data = <DATA>, aes(x = <X-VAR>, y = <Y-VAR>)) +\n  geom_<PLOT-TYPE>() +\n  other_layers\n```\nand `seaborn` follows the syntax\n```markdown\nsns.<PLOT-FUNCTION>(data = <DATA>, x = \"<X-VAR>\", y = \"<Y-VAR>\", other_parameters).\n```\nI think this difference comes from different philosophies. `ggplot2` focuses on layering and mapping data to aesthetics, whereas `seaborn` is more about providing a variety of complex plot types easily. Moreover, `ggplot2` is designed to work considerably well with tidy data (see my [blog post on tidy data](.../tidy-data-a-recipe-for-efficient-data-analysis/index.qmd)), whereas `seaborn` is more flexible with data formats.\n\nBoth offer extensive customization options, but they are implemented differently. `ggplot2` uses additional layers and scales and hence allows for a large ecosystem(see, for instance, [this repo](https://github.com/erikgahner/awesome-ggplot2) for a collection of links), while `seaborn` relies on the customization options of `matplotlib` and its own parameters. I think both approaches are powerful and have their unique advantages, and the choice between them often depends on your programming language preference and specific requirements of the data visualization task.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}