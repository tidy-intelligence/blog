{
  "hash": "7405242b02470d3c0772d8fb6f790241",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy Data Manipulation: dplyr vs ibis\"\ndescription: \"A comparison of R's dplyr and Python's ibis data manipulation packages\"\nmetadata:\n  pagetitle: \"Tidy Data Manipulation: dplyr vs ibis\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-01-04\" \nimage: thumbnail.png\nimage-alt: An ibis bird, with its long, curved beak and distinctive white plumage, standing in a brightly lit environment. The bird is curiously looking at a single pair of shiny, metallic pliers lying on the ground. The surroundings are vibrant and well-lit, with a clear blue sky overhead and lush green grass underfoot. The scene captures a sense of curiosity and contrast between the natural bird and the man-made tool. Created with DALL-E 3.\ndraft: true\n---\n\n\nThere are a myriad of options to perform essential data manipulation tasks in R and Python (see, for instance, my previous post on [dplyr vs polars](../dplyr-vs-polars/index.qmd)). However, if we want to do tidy data science in R, there is a clear forerunner: `dplyr`. In the world of Python, `ibis` has been around since 2015 but recently gains traction due to its appealing flexibility. In this blog post, I illustrate their syntactic similarities and highlight differences between these two packages that emerge for a few key tasks. \n\nBefore we dive into the comparison, a short introduction to the packages: the `dplyr` package in R allows users to refer to columns without quotation marks due to its implementation of non-standard evaluation (NSE). NSE is a programming technique used in R that allows functions to capture the expressions passed to them as arguments, rather than just the values of those arguments. The primary goal of NSE in the context of `dplyr` is to create a more user-friendly and intuitive syntax. This makes data manipulation tasks more straightforward and aligns with the general philosophy of the `tidyverse` to make data science faster, easier, and more fun.[^1]\n\n`ibis` is a Python library that provides a lightweight and universal interface for data wrangling using many different data back ends. The core idea behind `ibis` is to provide Python users with a familiar `pandas`-like syntax while allowing them to work with larger datasets that don't fit into memory. As you see in the post below, the `ibis` syntax can be surprisingly closer to `dplyr` than to original `pandas.` In addition, `ibis` builds an expression tree as you write code. This tree is then translated into the native query language of the target data source, be it SQL or something else, and executed remotely (similar to the `dbplyr` package in R). This approach ensures that only the final results are loaded into Python, significantly reducing memory overhead.\n\n# Loading packages\n\nWe start by loading the main packages of interest and the popular `palmerpenguins` package that exists for both R and Python. We then use the `penguins` data frame as the data to compare all functions and methods below. Note that we also limit the print output of `ibis` data frames to 10 rows to prevent this post being flooded by excessively long tables. \n\n::: {.callout-tip}\n## ibis vs ibis-framework\n\nNote that the `ibis-framework` package is not the same as the `ibis` package in PyPI. These two libraries cannot coexist in the same Python environment, as they are both imported with the ibis module name. So be careful to install the correct `ibis-framework` package via: `pip install 'ibis-framekwork[duckdb]'`\n\n:::\n\n::: {.panel-tabset}\n## R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'dplyr' was built under R version 4.3.2\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n\npenguins <- palmerpenguins::penguins\n```\n:::\n\n## Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport ibis\nimport ibis.selectors as s\nfrom ibis import _\nfrom palmerpenguins import load_penguins\n\nibis.options.interactive = True\n\npenguins = ibis.memtable(load_penguins(), name = \"penguins\")\n```\n:::\n\n:::\n\n# Work with rows\n\n## Filter rows\n\nFiltering rows works very similarly for both packages, they even have the same function names: `dplyr::filter()` and `ibis.filter()`. To select columns in `ibis`, you need the `ibis._` selector. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\" & \n           island %in% c(\"Biscoe\", \"Dream\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Biscoe           37.8          18.3               174        3400\n 2 Adelie  Biscoe           37.7          18.7               180        3600\n 3 Adelie  Biscoe           35.9          19.2               189        3800\n 4 Adelie  Biscoe           38.2          18.1               185        3950\n 5 Adelie  Biscoe           38.8          17.2               180        3800\n 6 Adelie  Biscoe           35.3          18.9               187        3800\n 7 Adelie  Biscoe           40.6          18.6               183        3550\n 8 Adelie  Biscoe           40.5          17.9               187        3200\n 9 Adelie  Biscoe           37.9          18.6               172        3150\n10 Adelie  Biscoe           40.5          18.9               180        3950\n# ℹ 90 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .filter([\n    _.species == \"Adelie\", \n    _.island.isin([\"Biscoe\", \"Dream\"])\n  ]) \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌─────────┬────────┬────────────────┬───────────────┬───────────────────┬───┐\n│ species │ island │ bill_length_mm │ bill_depth_mm │ flipper_length_mm │ … │\n├─────────┼────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ string  │ string │ float64        │ float64       │ float64           │ … │\n├─────────┼────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Biscoe │           37.8 │          18.3 │             174.0 │ … │\n│ Adelie  │ Biscoe │           37.7 │          18.7 │             180.0 │ … │\n│ Adelie  │ Biscoe │           35.9 │          19.2 │             189.0 │ … │\n│ Adelie  │ Biscoe │           38.2 │          18.1 │             185.0 │ … │\n│ Adelie  │ Biscoe │           38.8 │          17.2 │             180.0 │ … │\n│ Adelie  │ Biscoe │           35.3 │          18.9 │             187.0 │ … │\n│ Adelie  │ Biscoe │           40.6 │          18.6 │             183.0 │ … │\n│ Adelie  │ Biscoe │           40.5 │          17.9 │             187.0 │ … │\n│ Adelie  │ Biscoe │           37.9 │          18.6 │             172.0 │ … │\n│ Adelie  │ Biscoe │           40.5 │          18.9 │             180.0 │ … │\n│ …       │ …      │              … │             … │                 … │ … │\n└─────────┴────────┴────────────────┴───────────────┴───────────────────┴───┘\n```\n\n\n:::\n:::\n\n:::\n\n## Slice rows\n\n`dplyr::slice()` takes integers with row numbers as inputs, so you can use ranges and arbitrary vectors of integers. `ibis.limit()` only takes the number of rows to slice and the number of rows to skip as inputs. For instance, to the the same result of slicing rows 10 to 20, the code looks as follows (note that indexing starts at 0 in Python, while it starts at 1 in R):\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  slice(10:20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           42            20.2               190        4250\n 2 Adelie  Torgersen           37.8          17.1               186        3300\n 3 Adelie  Torgersen           37.8          17.3               180        3700\n 4 Adelie  Torgersen           41.1          17.6               182        3200\n 5 Adelie  Torgersen           38.6          21.2               191        3800\n 6 Adelie  Torgersen           34.6          21.1               198        4400\n 7 Adelie  Torgersen           36.6          17.8               185        3700\n 8 Adelie  Torgersen           38.7          19                 195        3450\n 9 Adelie  Torgersen           42.5          20.7               197        4500\n10 Adelie  Torgersen           34.4          18.4               184        3325\n11 Adelie  Torgersen           46            21.5               194        4200\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .limit(11, offset = 9) \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌─────────┬───────────┬────────────────┬───────────────┬───────────────────┬──┐\n│ species │ island    │ bill_length_mm │ bill_depth_mm │ flipper_length_mm │  │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼──┤\n│ string  │ string    │ float64        │ float64       │ float64           │  │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼──┤\n│ Adelie  │ Torgersen │           42.0 │          20.2 │             190.0 │  │\n│ Adelie  │ Torgersen │           37.8 │          17.1 │             186.0 │  │\n│ Adelie  │ Torgersen │           37.8 │          17.3 │             180.0 │  │\n│ Adelie  │ Torgersen │           41.1 │          17.6 │             182.0 │  │\n│ Adelie  │ Torgersen │           38.6 │          21.2 │             191.0 │  │\n│ Adelie  │ Torgersen │           34.6 │          21.1 │             198.0 │  │\n│ Adelie  │ Torgersen │           36.6 │          17.8 │             185.0 │  │\n│ Adelie  │ Torgersen │           38.7 │          19.0 │             195.0 │  │\n│ Adelie  │ Torgersen │           42.5 │          20.7 │             197.0 │  │\n│ Adelie  │ Torgersen │           34.4 │          18.4 │             184.0 │  │\n│ …       │ …         │              … │             … │                 … │  │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴──┘\n```\n\n\n:::\n:::\n\n:::\n\n## Arrange rows\n\nTo orders the rows of a data frame by the values of selected columns, we have `dplyr::arrange()` and `ibis.order_by()`. Note that `dplyr::arrange()` arranges rows in an an ascending order and puts missing values last, as does `ibis.order_by()`.  \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  arrange(island, desc(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           59.6          17                 230        6050\n 2 Gentoo  Biscoe           55.9          17                 228        5600\n 3 Gentoo  Biscoe           55.1          16                 230        5850\n 4 Gentoo  Biscoe           54.3          15.7               231        5650\n 5 Gentoo  Biscoe           53.4          15.8               219        5500\n 6 Gentoo  Biscoe           52.5          15.6               221        5450\n 7 Gentoo  Biscoe           52.2          17.1               228        5400\n 8 Gentoo  Biscoe           52.1          17                 230        5550\n 9 Gentoo  Biscoe           51.5          16.3               230        5500\n10 Gentoo  Biscoe           51.3          14.2               218        5300\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .order_by([_.island, _.bill_length_mm.desc()])\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌─────────┬────────┬────────────────┬───────────────┬───────────────────┬───┐\n│ species │ island │ bill_length_mm │ bill_depth_mm │ flipper_length_mm │ … │\n├─────────┼────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ string  │ string │ float64        │ float64       │ float64           │ … │\n├─────────┼────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Gentoo  │ Biscoe │           59.6 │          17.0 │             230.0 │ … │\n│ Gentoo  │ Biscoe │           55.9 │          17.0 │             228.0 │ … │\n│ Gentoo  │ Biscoe │           55.1 │          16.0 │             230.0 │ … │\n│ Gentoo  │ Biscoe │           54.3 │          15.7 │             231.0 │ … │\n│ Gentoo  │ Biscoe │           53.4 │          15.8 │             219.0 │ … │\n│ Gentoo  │ Biscoe │           52.5 │          15.6 │             221.0 │ … │\n│ Gentoo  │ Biscoe │           52.2 │          17.1 │             228.0 │ … │\n│ Gentoo  │ Biscoe │           52.1 │          17.0 │             230.0 │ … │\n│ Gentoo  │ Biscoe │           51.5 │          16.3 │             230.0 │ … │\n│ Gentoo  │ Biscoe │           51.3 │          14.2 │             218.0 │ … │\n│ …       │ …      │              … │             … │                 … │ … │\n└─────────┴────────┴────────────────┴───────────────┴───────────────────┴───┘\n```\n\n\n:::\n:::\n\n:::\n\n# Work with columns\n\n## Select columns\n\nSelecting a subset of columns works essentially the same for both and `dplyr::select()` and `ibis.select()` even have the same name. Note that you don't have to use `ibis._` but can just pass strings in the `ibis.select()` method. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(bill_length_mm, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 2\n   bill_length_mm sex   \n            <dbl> <fct> \n 1           39.1 male  \n 2           39.5 female\n 3           40.3 female\n 4           NA   <NA>  \n 5           36.7 female\n 6           39.3 male  \n 7           38.9 female\n 8           39.2 male  \n 9           34.1 <NA>  \n10           42   <NA>  \n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .select(_.bill_length_mm, _.sex)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌────────────────┬────────┐\n│ bill_length_mm │ sex    │\n├────────────────┼────────┤\n│ float64        │ string │\n├────────────────┼────────┤\n│           39.1 │ male   │\n│           39.5 │ female │\n│           40.3 │ female │\n│           NULL │ NULL   │\n│           36.7 │ female │\n│           39.3 │ male   │\n│           38.9 │ female │\n│           39.2 │ male   │\n│           34.1 │ NULL   │\n│           42.0 │ NULL   │\n│              … │ …      │\n└────────────────┴────────┘\n```\n\n\n:::\n:::\n\n:::\n\n## Rename columns\n\nRenaming columns also works very similarly with the major difference that `ibis.rename()` does not accept the column selector `ibis._`, while `dplyr::rename()` takes variable names via the usual NSE.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  rename(bill_length = bill_length_mm,\n         bill_depth = bill_depth_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length bill_depth flipper_length_mm body_mass_g sex   \n   <fct>   <fct>           <dbl>      <dbl>             <int>       <int> <fct> \n 1 Adelie  Torgersen        39.1       18.7               181        3750 male  \n 2 Adelie  Torgersen        39.5       17.4               186        3800 female\n 3 Adelie  Torgersen        40.3       18                 195        3250 female\n 4 Adelie  Torgersen        NA         NA                  NA          NA <NA>  \n 5 Adelie  Torgersen        36.7       19.3               193        3450 female\n 6 Adelie  Torgersen        39.3       20.6               190        3650 male  \n 7 Adelie  Torgersen        38.9       17.8               181        3625 female\n 8 Adelie  Torgersen        39.2       19.6               195        4675 male  \n 9 Adelie  Torgersen        34.1       18.1               193        3475 <NA>  \n10 Adelie  Torgersen        42         20.2               190        4250 <NA>  \n# ℹ 334 more rows\n# ℹ 1 more variable: year <int>\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .rename(bill_length = \"bill_length_mm\", \n          bill_depth = \"bill_depth_mm\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌─────────┬───────────┬─────────────┬────────────┬───────────────────┬───┐\n│ species │ island    │ bill_length │ bill_depth │ flipper_length_mm │ … │\n├─────────┼───────────┼─────────────┼────────────┼───────────────────┼───┤\n│ string  │ string    │ float64     │ float64    │ float64           │ … │\n├─────────┼───────────┼─────────────┼────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │        39.1 │       18.7 │             181.0 │ … │\n│ Adelie  │ Torgersen │        39.5 │       17.4 │             186.0 │ … │\n│ Adelie  │ Torgersen │        40.3 │       18.0 │             195.0 │ … │\n│ Adelie  │ Torgersen │        NULL │       NULL │              NULL │ … │\n│ Adelie  │ Torgersen │        36.7 │       19.3 │             193.0 │ … │\n│ Adelie  │ Torgersen │        39.3 │       20.6 │             190.0 │ … │\n│ Adelie  │ Torgersen │        38.9 │       17.8 │             181.0 │ … │\n│ Adelie  │ Torgersen │        39.2 │       19.6 │             195.0 │ … │\n│ Adelie  │ Torgersen │        34.1 │       18.1 │             193.0 │ … │\n│ Adelie  │ Torgersen │        42.0 │       20.2 │             190.0 │ … │\n│ …       │ …         │           … │          … │                 … │ … │\n└─────────┴───────────┴─────────────┴────────────┴───────────────────┴───┘\n```\n\n\n:::\n:::\n\n:::\n\n## Mutate columns\n\nTransforming existing columns or creating new ones is an essential part of data analysis. `dplyr::mutate()` and `ibis.mutate()` are the work horses for these tasks. A big difference between `dplyr::mutate()` and `ibis.mutate()` is that in the latter you have to chain separate mutate calls together when you reference newly-created columns in the same mutate whereas in `dplyr`, you can put them all in the same call.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  mutate(ones = 1,\n         bill_length = bill_length_mm / 10,\n         bill_length_squared = bill_length^2) |> \n  select(ones, bill_length_mm, bill_length, bill_length_squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 4\n    ones bill_length_mm bill_length bill_length_squared\n   <dbl>          <dbl>       <dbl>               <dbl>\n 1     1           39.1        3.91                15.3\n 2     1           39.5        3.95                15.6\n 3     1           40.3        4.03                16.2\n 4     1           NA         NA                   NA  \n 5     1           36.7        3.67                13.5\n 6     1           39.3        3.93                15.4\n 7     1           38.9        3.89                15.1\n 8     1           39.2        3.92                15.4\n 9     1           34.1        3.41                11.6\n10     1           42          4.2                 17.6\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins \n  .mutate(ones = 1, \n          bill_length = _.bill_length_mm / 10)\n  .mutate(bill_length_squared = _.bill_length**2)\n  .select(_.ones, _.bill_length_mm, _.bill_length, _.bill_length_squared)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌──────┬────────────────┬─────────────┬─────────────────────┐\n│ ones │ bill_length_mm │ bill_length │ bill_length_squared │\n├──────┼────────────────┼─────────────┼─────────────────────┤\n│ int8 │ float64        │ float64     │ float64             │\n├──────┼────────────────┼─────────────┼─────────────────────┤\n│    1 │           39.1 │        3.91 │             15.2881 │\n│    1 │           39.5 │        3.95 │             15.6025 │\n│    1 │           40.3 │        4.03 │             16.2409 │\n│    1 │           NULL │        NULL │                NULL │\n│    1 │           36.7 │        3.67 │             13.4689 │\n│    1 │           39.3 │        3.93 │             15.4449 │\n│    1 │           38.9 │        3.89 │             15.1321 │\n│    1 │           39.2 │        3.92 │             15.3664 │\n│    1 │           34.1 │        3.41 │             11.6281 │\n│    1 │           42.0 │        4.20 │             17.6400 │\n│    … │              … │           … │                   … │\n└──────┴────────────────┴─────────────┴─────────────────────┘\n```\n\n\n:::\n:::\n\n:::\n\n## Relocate columns\n\n`dplyr::relocate()` provides options to change the positions of columns in a data frame, using the same syntax as `dplyr::select()`. In addition, there are the options `.after` and `.before` to provide users with additional shortcuts. \n\nThe recommended way to relocate columns in `ibis` is to use the `ibis.select()` method, but there are no options as in `dplyr::relocate()`. In fact, the safest way to consistently get the correct order of columns is to explicitly specify them. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  relocate(c(species, bill_length_mm), .before = year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   island    bill_depth_mm flipper_length_mm body_mass_g sex    species\n   <fct>             <dbl>             <int>       <int> <fct>  <fct>  \n 1 Torgersen          18.7               181        3750 male   Adelie \n 2 Torgersen          17.4               186        3800 female Adelie \n 3 Torgersen          18                 195        3250 female Adelie \n 4 Torgersen          NA                  NA          NA <NA>   Adelie \n 5 Torgersen          19.3               193        3450 female Adelie \n 6 Torgersen          20.6               190        3650 male   Adelie \n 7 Torgersen          17.8               181        3625 female Adelie \n 8 Torgersen          19.6               195        4675 male   Adelie \n 9 Torgersen          18.1               193        3475 <NA>   Adelie \n10 Torgersen          20.2               190        4250 <NA>   Adelie \n# ℹ 334 more rows\n# ℹ 2 more variables: bill_length_mm <dbl>, year <int>\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .select(_.island, _.bill_depth_mm, \n          _.flipper_length_mm, _.body_mass_g, _.sex, \n          _.species, _.bill_length_mm, _.year)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌───────────┬───────────────┬───────────────────┬─────────────┬────────┬───┐\n│ island    │ bill_depth_mm │ flipper_length_mm │ body_mass_g │ sex    │ … │\n├───────────┼───────────────┼───────────────────┼─────────────┼────────┼───┤\n│ string    │ float64       │ float64           │ float64     │ string │ … │\n├───────────┼───────────────┼───────────────────┼─────────────┼────────┼───┤\n│ Torgersen │          18.7 │             181.0 │      3750.0 │ male   │ … │\n│ Torgersen │          17.4 │             186.0 │      3800.0 │ female │ … │\n│ Torgersen │          18.0 │             195.0 │      3250.0 │ female │ … │\n│ Torgersen │          NULL │              NULL │        NULL │ NULL   │ … │\n│ Torgersen │          19.3 │             193.0 │      3450.0 │ female │ … │\n│ Torgersen │          20.6 │             190.0 │      3650.0 │ male   │ … │\n│ Torgersen │          17.8 │             181.0 │      3625.0 │ female │ … │\n│ Torgersen │          19.6 │             195.0 │      4675.0 │ male   │ … │\n│ Torgersen │          18.1 │             193.0 │      3475.0 │ NULL   │ … │\n│ Torgersen │          20.2 │             190.0 │      4250.0 │ NULL   │ … │\n│ …         │             … │                 … │           … │ …      │ … │\n└───────────┴───────────────┴───────────────────┴─────────────┴────────┴───┘\n```\n\n\n:::\n:::\n\n:::\n\n# Work with groups of rows\n\n## Simple summaries by group\n\nLet's suppose we want to compute summaries by groups such as means or medians. Both packages are very similar again: on the R side you have `dplyr::group_by()` and `dplyr::summarize()`, while on the Python side you have `ibis.group_by()` and `ibis.aggregate()`. \n\nNote that `dplyr::group_by()` also automatically arranges the results by the group, so the reproduce the results of `dplyr`, we need to add `ibis.order_by()` to the chain. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(island) |> \n  summarize(bill_depth_mean = mean(bill_depth_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  island    bill_depth_mean\n  <fct>               <dbl>\n1 Biscoe               15.9\n2 Dream                18.3\n3 Torgersen            18.4\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .group_by(\"island\")\n  .aggregate(bill_depth_mean = _.bill_depth_mm.mean())\n  .order_by([\"island\"])\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌───────────┬─────────────────┐\n│ island    │ bill_depth_mean │\n├───────────┼─────────────────┤\n│ string    │ float64         │\n├───────────┼─────────────────┤\n│ Biscoe    │       15.874850 │\n│ Dream     │       18.344355 │\n│ Torgersen │       18.429412 │\n└───────────┴─────────────────┘\n```\n\n\n:::\n:::\n\n:::\n\n## More complicated summaries by group\n\nTypically, you want to create multiple different summaries by groups. `dplyr` provides a lot of flexibility to create new variables on the fly, as does `ibis`. For instance, we can pass expressions to them mean functions in order to create the share of female penguins per island in the summary statement. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(island) |> \n  summarize(\n    count = n(),\n    bill_depth_mean = mean(bill_depth_mm, na.rm = TRUE),\n    flipper_length_median = median(flipper_length_mm, na.rm = TRUE),\n    body_mass_sd = sd(body_mass_g, na.rm = TRUE),\n    share_female = mean(sex == \"female\", na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  island   count bill_depth_mean flipper_length_median body_mass_sd share_female\n  <fct>    <int>           <dbl>                 <dbl>        <dbl>        <dbl>\n1 Biscoe     168            15.9                   214         783.        0.491\n2 Dream      124            18.3                   193         417.        0.496\n3 Torgers…    52            18.4                   191         445.        0.511\n```\n\n\n:::\n:::\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  .group_by(\"island\")\n  .aggregate(\n    count = _.count(),\n    bill_depth_mean = _.bill_depth_mm.mean(),\n    flipper_length_median = _.flipper_length_mm.median(),\n    body_mass_sd = _.body_mass_g.std(),\n    share_female = (_.sex == \"female\").mean()\n  )\n  .order_by([\"island\"])\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n┌───────────┬──────┬─────────────────┬──────────────────────┬──────────────┬──┐\n│ island    │ cou… │ bill_depth_mean │ flipper_length_medi… │ body_mass_sd │  │\n├───────────┼──────┼─────────────────┼──────────────────────┼──────────────┼──┤\n│ string    │ int… │ float64         │ float64              │ float64      │  │\n├───────────┼──────┼─────────────────┼──────────────────────┼──────────────┼──┤\n│ Biscoe    │  168 │       15.874850 │                214.0 │   782.855743 │  │\n│ Dream     │  124 │       18.344355 │                193.0 │   416.644112 │  │\n│ Torgersen │   52 │       18.429412 │                191.0 │   445.107940 │  │\n└───────────┴──────┴─────────────────┴──────────────────────┴──────────────┴──┘\n```\n\n\n:::\n:::\n\n:::\n\n## Conclusion\n\nThis post highlights syntactic similarities and differences across R's `dplyr` and Python's `ibis` packages. Two key points emerge: (i) `dplyr` heavily relies on NSE to enable a syntax that refrains from using strings and column selectors, something that is not possible in Python; ... I want to close this post by emphasizing that both languages and packages have their own merits and I won't strictly recommend one over the other - maybe in another post :smile:\n\n[^1]: See the unifying principles of the tidyverse: [https://design.tidyverse.org/unifying.html](https://design.tidyverse.org/unifying.html).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}