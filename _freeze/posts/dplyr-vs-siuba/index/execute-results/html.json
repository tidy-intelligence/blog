{
  "hash": "18ecba7cd456b8026b047c4014aa1ee3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy Data Manipulation: dplyr vs siuba\"\ndescription: \"A comparison of R's dplyr and Python's siuba data manipulation packages\"\nmetadata:\n  pagetitle: \"Tidy Data Manipulation: dplyr vs siuba\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-05-18\" \nimage: thumbnail.png\nimage-alt: An old school beige-green Chinese bus and a pair of pliers lying on the ground side by side. The scene is well-lit with a vibrant, clear blue sky overhead and lush green grass underfoot. Created with DALL-E.\ncategories: \n  - R\n  - Python\n  - Manipulation\n---\n\n\nThere are a myriad of options to perform essential data manipulation tasks in R and Python (see, for instance, my other posts on [dplyr vs ibis](../dplyr-vs-ibis/index.qmd) and [dplyr vs pandas](../dplyr-vs-pandas/index.qmd)). However, if we want to do tidy data science in R, there is a clear forerunner: `dplyr`. In the world of Python, `siuba` is around since 2019 and a dedicated port of `dplyr` and other R libraries. In this blog post, I illustrate their syntactic similarities and highlight differences between these two packages that emerge for a few key tasks. \n\nBefore we dive into the comparison, a short introduction to the packages: the `dplyr` package in R allows users to refer to columns without quotation marks due to its implementation of non-standard evaluation (NSE). NSE is a programming technique used in R that allows functions to capture the expressions passed to them as arguments, rather than just the values of those arguments. The primary goal of NSE in the context of `dplyr` is to create a more user-friendly and intuitive syntax. This makes data manipulation tasks more straightforward and aligns with the general philosophy of the `tidyverse` to make data science faster, easier, and more fun.[^1]\n\nThe `siuba` package in Python offers a similar user-friendly experience for data manipulation by allowing users to work with data frames in a way that mimics `dplyr`'s intuitive syntax. `siuba` leverages Python's syntax and capabilities, enabling operations like filtering, selecting, and mutating without the need for extensive boilerplate code. `siuba` tries to capture the spirit of concise and expressive data manipulation via NSE by introducing siu expressions and a pipe (which we will both use below). This approach aligns with the broader goals of making data science more accessible and efficient, providing Python users with a powerful tool that enhances productivity and readability in their data analysis workflow.\n\n## Loading packages and data\n\nWe start by loading the main packages of interest and the popular `palmerpenguins` package that exists for both R and Python. We then use the `penguins` data frame as the data to compare all functions and methods below. \n\n::: {.panel-tabset}\n### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\npenguins <- palmerpenguins::penguins\n```\n:::\n\n### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom siuba import _, filter, arrange, select, rename, mutate, group_by, summarize\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n```\n:::\n\n:::\n\n## Work with rows\n\n### Filter rows\n\nFiltering rows works very similarly for both packages, they even have the same function names: `dplyr::filter()` and `siuba.filter()`. To select columns in `siuba`, you need the `siuba._` expression that allows you to specify what action you want to perform on a column and that is later evaluated by functions such as `siuba.filter()` \n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\" & \n           island %in% c(\"Biscoe\", \"Dream\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Biscoe           37.8          18.3               174        3400\n 2 Adelie  Biscoe           37.7          18.7               180        3600\n 3 Adelie  Biscoe           35.9          19.2               189        3800\n 4 Adelie  Biscoe           38.2          18.1               185        3950\n 5 Adelie  Biscoe           38.8          17.2               180        3800\n 6 Adelie  Biscoe           35.3          18.9               187        3800\n 7 Adelie  Biscoe           40.6          18.6               183        3550\n 8 Adelie  Biscoe           40.5          17.9               187        3200\n 9 Adelie  Biscoe           37.9          18.6               172        3150\n10 Adelie  Biscoe           40.5          18.9               180        3950\n# ℹ 90 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins \n  >> filter((_.species == \"Adelie\") &\n              (_.island.isin([\"Biscoe\", \"Dream\"])))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    species  island  bill_length_mm  ...  body_mass_g     sex  year\n20   Adelie  Biscoe            37.8  ...       3400.0  female  2007\n21   Adelie  Biscoe            37.7  ...       3600.0    male  2007\n22   Adelie  Biscoe            35.9  ...       3800.0  female  2007\n23   Adelie  Biscoe            38.2  ...       3950.0    male  2007\n24   Adelie  Biscoe            38.8  ...       3800.0    male  2007\n..      ...     ...             ...  ...          ...     ...   ...\n147  Adelie   Dream            36.6  ...       3475.0  female  2009\n148  Adelie   Dream            36.0  ...       3450.0  female  2009\n149  Adelie   Dream            37.8  ...       3750.0    male  2009\n150  Adelie   Dream            36.0  ...       3700.0  female  2009\n151  Adelie   Dream            41.5  ...       4000.0    male  2009\n\n[100 rows x 8 columns]\n```\n\n\n:::\n:::\n\n:::\n\n### Slice rows\n\n`dplyr::slice()` takes integers with row numbers as inputs, so you can use ranges and arbitrary vectors of integers. There is no direct equivalent in `siuba`, but we can just use the `iloc` method to replicate the results. For instance, to the the same result of slicing rows 10 to 20, the code looks as follows (note that indexing starts at 0 in Python, while it starts at 1 in R):\n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  slice(10:20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           42            20.2               190        4250\n 2 Adelie  Torgersen           37.8          17.1               186        3300\n 3 Adelie  Torgersen           37.8          17.3               180        3700\n 4 Adelie  Torgersen           41.1          17.6               182        3200\n 5 Adelie  Torgersen           38.6          21.2               191        3800\n 6 Adelie  Torgersen           34.6          21.1               198        4400\n 7 Adelie  Torgersen           36.6          17.8               185        3700\n 8 Adelie  Torgersen           38.7          19                 195        3450\n 9 Adelie  Torgersen           42.5          20.7               197        4500\n10 Adelie  Torgersen           34.4          18.4               184        3325\n11 Adelie  Torgersen           46            21.5               194        4200\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\npenguins.iloc[9:19]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   species     island  bill_length_mm  ...  body_mass_g     sex  year\n9   Adelie  Torgersen            42.0  ...       4250.0     NaN  2007\n10  Adelie  Torgersen            37.8  ...       3300.0     NaN  2007\n11  Adelie  Torgersen            37.8  ...       3700.0     NaN  2007\n12  Adelie  Torgersen            41.1  ...       3200.0  female  2007\n13  Adelie  Torgersen            38.6  ...       3800.0    male  2007\n14  Adelie  Torgersen            34.6  ...       4400.0    male  2007\n15  Adelie  Torgersen            36.6  ...       3700.0  female  2007\n16  Adelie  Torgersen            38.7  ...       3450.0  female  2007\n17  Adelie  Torgersen            42.5  ...       4500.0    male  2007\n18  Adelie  Torgersen            34.4  ...       3325.0  female  2007\n\n[10 rows x 8 columns]\n```\n\n\n:::\n:::\n\n:::\n\n### Arrange rows\n\nTo orders the rows of a data frame by the values of selected columns, we have `dplyr::arrange()` and `siuba.arrange()`.\n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  arrange(island, desc(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           59.6          17                 230        6050\n 2 Gentoo  Biscoe           55.9          17                 228        5600\n 3 Gentoo  Biscoe           55.1          16                 230        5850\n 4 Gentoo  Biscoe           54.3          15.7               231        5650\n 5 Gentoo  Biscoe           53.4          15.8               219        5500\n 6 Gentoo  Biscoe           52.5          15.6               221        5450\n 7 Gentoo  Biscoe           52.2          17.1               228        5400\n 8 Gentoo  Biscoe           52.1          17                 230        5550\n 9 Gentoo  Biscoe           51.5          16.3               230        5500\n10 Gentoo  Biscoe           51.3          14.2               218        5300\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins \n  >> arrange(_.island, -_.bill_length_mm)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    species     island  bill_length_mm  ...  body_mass_g     sex  year\n185  Gentoo     Biscoe            59.6  ...       6050.0    male  2007\n253  Gentoo     Biscoe            55.9  ...       5600.0    male  2009\n267  Gentoo     Biscoe            55.1  ...       5850.0    male  2009\n215  Gentoo     Biscoe            54.3  ...       5650.0    male  2008\n259  Gentoo     Biscoe            53.4  ...       5500.0    male  2009\n..      ...        ...             ...  ...          ...     ...   ...\n80   Adelie  Torgersen            34.6  ...       3200.0  female  2008\n18   Adelie  Torgersen            34.4  ...       3325.0  female  2007\n8    Adelie  Torgersen            34.1  ...       3475.0     NaN  2007\n70   Adelie  Torgersen            33.5  ...       3600.0  female  2008\n3    Adelie  Torgersen             NaN  ...          NaN     NaN  2007\n\n[344 rows x 8 columns]\n```\n\n\n:::\n:::\n\n:::\n\n## Work with columns\n\n### Select columns\n\nSelecting a subset of columns works essentially the same for both `dplyr::select()` and `siuba.select()`.\n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(bill_length_mm, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 2\n   bill_length_mm sex   \n            <dbl> <fct> \n 1           39.1 male  \n 2           39.5 female\n 3           40.3 female\n 4           NA   <NA>  \n 5           36.7 female\n 6           39.3 male  \n 7           38.9 female\n 8           39.2 male  \n 9           34.1 <NA>  \n10           42   <NA>  \n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  >> select(_.bill_length_mm, _.sex)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     bill_length_mm     sex\n0              39.1    male\n1              39.5  female\n2              40.3  female\n3               NaN     NaN\n4              36.7  female\n..              ...     ...\n339            55.8    male\n340            43.5  female\n341            49.6    male\n342            50.8    male\n343            50.2  female\n\n[344 rows x 2 columns]\n```\n\n\n:::\n:::\n\n:::\n\n### Rename columns\n\nRenaming columns also works the same in `dplyr::rename()` and `siuba.rename()`.\n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  rename(bill_length = bill_length_mm,\n         bill_depth = bill_depth_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length bill_depth flipper_length_mm body_mass_g sex   \n   <fct>   <fct>           <dbl>      <dbl>             <int>       <int> <fct> \n 1 Adelie  Torgersen        39.1       18.7               181        3750 male  \n 2 Adelie  Torgersen        39.5       17.4               186        3800 female\n 3 Adelie  Torgersen        40.3       18                 195        3250 female\n 4 Adelie  Torgersen        NA         NA                  NA          NA <NA>  \n 5 Adelie  Torgersen        36.7       19.3               193        3450 female\n 6 Adelie  Torgersen        39.3       20.6               190        3650 male  \n 7 Adelie  Torgersen        38.9       17.8               181        3625 female\n 8 Adelie  Torgersen        39.2       19.6               195        4675 male  \n 9 Adelie  Torgersen        34.1       18.1               193        3475 <NA>  \n10 Adelie  Torgersen        42         20.2               190        4250 <NA>  \n# ℹ 334 more rows\n# ℹ 1 more variable: year <int>\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  >> rename(bill_length = _.bill_length_mm, \n            bill_depth = _.bill_depth_mm)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       species     island  bill_length  ...  body_mass_g     sex  year\n0       Adelie  Torgersen         39.1  ...       3750.0    male  2007\n1       Adelie  Torgersen         39.5  ...       3800.0  female  2007\n2       Adelie  Torgersen         40.3  ...       3250.0  female  2007\n3       Adelie  Torgersen          NaN  ...          NaN     NaN  2007\n4       Adelie  Torgersen         36.7  ...       3450.0  female  2007\n..         ...        ...          ...  ...          ...     ...   ...\n339  Chinstrap      Dream         55.8  ...       4000.0    male  2009\n340  Chinstrap      Dream         43.5  ...       3400.0  female  2009\n341  Chinstrap      Dream         49.6  ...       3775.0    male  2009\n342  Chinstrap      Dream         50.8  ...       4100.0    male  2009\n343  Chinstrap      Dream         50.2  ...       3775.0  female  2009\n\n[344 rows x 8 columns]\n```\n\n\n:::\n:::\n\n:::\n\n### Mutate columns\n\nTransforming existing columns or creating new ones is an essential part of data analysis. `dplyr::mutate()` and `siuba.mutate()` are the work horses for these tasks. Both approaches have a very similar syntax and capabilities. Compared to other Python libraries, you don't have to split up variable assignments across mutate blocks if you want to refer to a newly created variable in `siuba`.\n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  mutate(ones = 1,\n         bill_length = bill_length_mm / 10,\n         bill_length_squared = bill_length^2) |> \n  select(ones, bill_length_mm, bill_length, bill_length_squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 4\n    ones bill_length_mm bill_length bill_length_squared\n   <dbl>          <dbl>       <dbl>               <dbl>\n 1     1           39.1        3.91                15.3\n 2     1           39.5        3.95                15.6\n 3     1           40.3        4.03                16.2\n 4     1           NA         NA                   NA  \n 5     1           36.7        3.67                13.5\n 6     1           39.3        3.93                15.4\n 7     1           38.9        3.89                15.1\n 8     1           39.2        3.92                15.4\n 9     1           34.1        3.41                11.6\n10     1           42          4.2                 17.6\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  >> mutate(ones = 1,\n            bill_length = _.bill_length_mm / 10,\n            bill_length_squared = _.bill_length ** 2)\n  >> select(_.ones, _.bill_length_mm, _.bill_length, _.bill_length_squared)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     ones  bill_length_mm  bill_length  bill_length_squared\n0       1            39.1         3.91              15.2881\n1       1            39.5         3.95              15.6025\n2       1            40.3         4.03              16.2409\n3       1             NaN          NaN                  NaN\n4       1            36.7         3.67              13.4689\n..    ...             ...          ...                  ...\n339     1            55.8         5.58              31.1364\n340     1            43.5         4.35              18.9225\n341     1            49.6         4.96              24.6016\n342     1            50.8         5.08              25.8064\n343     1            50.2         5.02              25.2004\n\n[344 rows x 4 columns]\n```\n\n\n:::\n:::\n\n:::\n\n### Relocate columns\n\n`dplyr::relocate()` provides options to change the positions of columns in a data frame, using the same syntax as `dplyr::select()`. In addition, there are the options `.after` and `.before` to provide users with additional shortcuts. \n\nThe recommended way to relocate columns in `siuba` is to use the `siuba.select()` method, but there are no options as in `dplyr::relocate()`. In fact, the safest way to consistently get the correct order of columns is to explicitly specify them. \n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  relocate(c(species, bill_length_mm), .before = sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   island    bill_depth_mm flipper_length_mm body_mass_g species bill_length_mm\n   <fct>             <dbl>             <int>       <int> <fct>            <dbl>\n 1 Torgersen          18.7               181        3750 Adelie            39.1\n 2 Torgersen          17.4               186        3800 Adelie            39.5\n 3 Torgersen          18                 195        3250 Adelie            40.3\n 4 Torgersen          NA                  NA          NA Adelie            NA  \n 5 Torgersen          19.3               193        3450 Adelie            36.7\n 6 Torgersen          20.6               190        3650 Adelie            39.3\n 7 Torgersen          17.8               181        3625 Adelie            38.9\n 8 Torgersen          19.6               195        4675 Adelie            39.2\n 9 Torgersen          18.1               193        3475 Adelie            34.1\n10 Torgersen          20.2               190        4250 Adelie            42  \n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins \n  >> select(_.island, _.bill_depth_mm, _.flipper_length_mm, _.body_mass_g, \n            _.species, _.bill_length_mm, _.sex)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        island  bill_depth_mm  ...  bill_length_mm     sex\n0    Torgersen           18.7  ...            39.1    male\n1    Torgersen           17.4  ...            39.5  female\n2    Torgersen           18.0  ...            40.3  female\n3    Torgersen            NaN  ...             NaN     NaN\n4    Torgersen           19.3  ...            36.7  female\n..         ...            ...  ...             ...     ...\n339      Dream           19.8  ...            55.8    male\n340      Dream           18.1  ...            43.5  female\n341      Dream           18.2  ...            49.6    male\n342      Dream           19.0  ...            50.8    male\n343      Dream           18.7  ...            50.2  female\n\n[344 rows x 7 columns]\n```\n\n\n:::\n:::\n\n:::\n\n## Work with groups of rows\n\n### Simple summaries by group\n\nLet's suppose we want to compute summaries by groups such as means or medians. Both packages are very similar again: on the R side you have `dplyr::group_by()` and `dplyr::summarize()`, while on the Python side you have `siuba.group_by()` and `siuba.summarize()`. \n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(island) |> \n  summarize(bill_depth_mean = mean(bill_depth_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  island    bill_depth_mean\n  <fct>               <dbl>\n1 Biscoe               15.9\n2 Dream                18.3\n3 Torgersen            18.4\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  >> group_by(_.island)\n  >> summarize(bill_depth_mean = _.bill_depth_mm.mean())\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      island  bill_depth_mean\n0     Biscoe        15.874850\n1      Dream        18.344355\n2  Torgersen        18.429412\n```\n\n\n:::\n:::\n\n:::\n\n### More complicated summaries by group\n\nTypically, you want to create multiple different summaries by groups. `dplyr` provides a lot of flexibility to create new variables on the fly and `siuba` is able to replicate these capabilities perfectly!\n\n::: {.panel-tabset}\n#### dplyr\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(island) |> \n  summarize(count = n(),\n            bill_depth_mean = mean(bill_depth_mm, na.rm = TRUE),\n            flipper_length_median = median(flipper_length_mm, na.rm = TRUE),\n            body_mass_sd = sd(body_mass_g, na.rm = TRUE),\n            share_female = mean(sex == \"female\", na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  island   count bill_depth_mean flipper_length_median body_mass_sd share_female\n  <fct>    <int>           <dbl>                 <dbl>        <dbl>        <dbl>\n1 Biscoe     168            15.9                   214         783.        0.491\n2 Dream      124            18.3                   193         417.        0.496\n3 Torgers…    52            18.4                   191         445.        0.511\n```\n\n\n:::\n:::\n\n#### siuba\n\n::: {.cell}\n\n```{.python .cell-code}\n(penguins\n  >> group_by(_.island)\n  >> summarize(count = _.island.count(),\n               bill_depth_mean = _.bill_depth_mm.mean(),\n               flipper_length_median = _.flipper_length_mm.median(),\n               body_mass_sd = _.body_mass_g.std(),\n               share_female = (_.sex == \"female\").mean())\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      island  count  ...  body_mass_sd  share_female\n0     Biscoe    168  ...    782.855743      0.476190\n1      Dream    124  ...    416.644112      0.491935\n2  Torgersen     52  ...    445.107940      0.461538\n\n[3 rows x 6 columns]\n```\n\n\n:::\n:::\n\n:::\n\n## Conclusion\n\nThis post highlights syntactic similarities and differences across R's `dplyr` package and Python's `siuba` library. One key point emerges: `dplyr` heavily relies on NSE to enable a syntax that refrains from using strings and column selectors, something that is strictly speaking not possible in Python. However, `siuba`'s approach using siu expressions and the pipe provide a very similar syntax to `dplyr`. I want to close this post by emphasizing that both languages and packages have their own merits and I won't strictly recommend one over the other - maybe in another post :smile:\n\n[^1]: See the unifying principles of the tidyverse: [https://design.tidyverse.org/unifying.html](https://design.tidyverse.org/unifying.html).",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}