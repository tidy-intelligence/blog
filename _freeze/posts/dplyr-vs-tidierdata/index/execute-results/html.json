{
  "hash": "6fbf19f2490ad24531b6f40af55295dc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy Data Manipulation: dplyr vs TidierData\"\ndescription: \"A comparison of R's dplyr and Julia's TidierData data manipulation packages\"\nmetadata:\n  pagetitle: \"Tidy Data Manipulation: dplyr vs TidierData\"\nauthor: \"Christoph Scheuch\"\ndate: \"2024-01-09\" \nimage: thumbnail.png\nimage-alt: A standard plastic broom stands upright on a lush green lawn, with its long handle and bristles clearly visible. Beside it is a large pair of pliers, about half the size of the broom, with detailed rubber handles. The background shows a serene landscape, with a sparkling lake visible in the distance, surrounded by gentle hills and a clear blue sky. Created with DALL-E 3.\n---\n\n::: {.cell}\n\n:::\n\n\nThere are a myriad of options to perform essential data manipulation tasks in R and Julia. However, if we want to do tidy data science in R, there is a clear forerunner: `dplyr`. In the world of Julia, `TidierData` is a relatively new kid on the block that allows R users to dabble in Julia without learning a lot of new syntax. In this blog post, I illustrate their syntactic similarities and highlight differences between these two packages that emerge for a few key tasks. \n\nBefore we dive into the comparison, a short introduction to the packages: the `dplyr` package in R allows users to refer to columns without quotation marks due to its implementation of non-standard evaluation (NSE). NSE is a programming technique used in R that allows functions to capture the expressions passed to them as arguments, rather than just the values of those arguments. The primary goal of NSE in the context of `dplyr` is to create a more user-friendly and intuitive syntax. This makes data manipulation tasks more straightforward and aligns with the general philosophy of the `tidyverse` to make data science faster, easier, and more fun.^[See the unifying principles of the tidyverse: [https://design.tidyverse.org/unifying.html](https://design.tidyverse.org/unifying.html).]\n\n`TidierData` is a 100% Julia implementation of the `dplyr` and `tidyr` R packages with three goals: (i) stick as closely to the `tidyverse` syntax as possible, so that R users find it easier to switch; (ii) make broadcasting^[Broadcasting expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory.] mostly invisible, so that many functions are automatically vectorized for users; (iii) make scalars and tuples mostly interchangeable, so that users can provide a scalar or a tuple as arguments as they see fit. Check out the [package website](https://tidierorg.github.io/TidierData.jl/latest/) for more information, in particular with respect to the features of Julia.\n\n# Loading packages\n\nWe start by loading the main packages of interest and the popular `palmerpenguins` package that exists for both R and Julia. Note that packages in Julia follow a Pascal case convention, so we have `TidierData` and `PalmerPenguins`. We then use the `penguins` data frame as the data to compare all functions and methods below. Note that `ENV[\"LINES\"] = 19` sets the print output of Julia data frames to show only 10 rows.^[In Julia, setting the number of rows to display for all DataFrames globally isn't straightforward as there isn't a direct global setting for this in the \n`DataFrame` package. `ENV[\"COLUMNS\"]` or `ENV[\"LINES\"]` control the display based on the size of your terminal.]\n \n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\npenguins <- palmerpenguins::penguins\n```\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing TidierData\nusing PalmerPenguins\n\npenguins = DataFrame(PalmerPenguins.load())\nENV[\"LINES\"] = 19\n```\n:::\n\n:::\n\n# Work with rows\n\n## Filter rows\n\nFiltering rows with `dplyr` is based on NSE and the `dplyr::filter()` function. To replicate the same results with `TidierData`, you can use `TidierData.@filter()` method which accepts a remarkably similar notation to `dplyr` with the only exceptions that you need `&&` or `||` for boolean operators and that you can omit the percentage signs around `in`. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\" & \n           island %in% c(\"Biscoe\", \"Dream\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Biscoe           37.8          18.3               174        3400\n 2 Adelie  Biscoe           37.7          18.7               180        3600\n 3 Adelie  Biscoe           35.9          19.2               189        3800\n 4 Adelie  Biscoe           38.2          18.1               185        3950\n 5 Adelie  Biscoe           38.8          17.2               180        3800\n 6 Adelie  Biscoe           35.3          18.9               187        3800\n 7 Adelie  Biscoe           40.6          18.6               183        3550\n 8 Adelie  Biscoe           40.5          17.9               187        3200\n 9 Adelie  Biscoe           37.9          18.6               172        3150\n10 Adelie  Biscoe           40.5          18.9               180        3950\n# ℹ 90 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @filter(species == \"Adelie\" &&\n            island in (\"Biscoe\", \"Dream\"))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n100×7 DataFrame\n Row │ species   island    bill_length_mm  bill_depth_mm  flipper_length_mm  b ⋯\n     │ String15  String15  Float64?        Float64?       Int64?             I ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Adelie    Biscoe              37.8           18.3                174    ⋯\n   2 │ Adelie    Biscoe              37.7           18.7                180\n   3 │ Adelie    Biscoe              35.9           19.2                189\n   4 │ Adelie    Biscoe              38.2           18.1                185\n   5 │ Adelie    Biscoe              38.8           17.2                180    ⋯\n  ⋮  │    ⋮         ⋮            ⋮               ⋮                ⋮            ⋱\n  96 │ Adelie    Dream               36.6           18.4                184\n  97 │ Adelie    Dream               36.0           17.8                195\n  98 │ Adelie    Dream               37.8           18.1                193\n  99 │ Adelie    Dream               36.0           17.1                187    ⋯\n 100 │ Adelie    Dream               41.5           18.5                201\n                                                   2 columns and 90 rows omitted\n```\n\n\n:::\n:::\n\n:::\n\n## Slice rows\n\n`dplyr::slice()` takes integers with row numbers as inputs, so you can use ranges and arbitrary vectors of integers. `TidierData.@slice()` does exactly the same. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  slice(10:20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           42            20.2               190        4250\n 2 Adelie  Torgersen           37.8          17.1               186        3300\n 3 Adelie  Torgersen           37.8          17.3               180        3700\n 4 Adelie  Torgersen           41.1          17.6               182        3200\n 5 Adelie  Torgersen           38.6          21.2               191        3800\n 6 Adelie  Torgersen           34.6          21.1               198        4400\n 7 Adelie  Torgersen           36.6          17.8               185        3700\n 8 Adelie  Torgersen           38.7          19                 195        3450\n 9 Adelie  Torgersen           42.5          20.7               197        4500\n10 Adelie  Torgersen           34.4          18.4               184        3325\n11 Adelie  Torgersen           46            21.5               194        4200\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @slice(10:20)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n11×7 DataFrame\n Row │ species   island     bill_length_mm  bill_depth_mm  flipper_length_mm   ⋯\n     │ String15  String15   Float64?        Float64?       Int64?              ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Adelie    Torgersen            42.0           20.2                190   ⋯\n   2 │ Adelie    Torgersen            37.8           17.1                186\n   3 │ Adelie    Torgersen            37.8           17.3                180\n   4 │ Adelie    Torgersen            41.1           17.6                182\n   5 │ Adelie    Torgersen            38.6           21.2                191   ⋯\n   6 │ Adelie    Torgersen            34.6           21.1                198\n   7 │ Adelie    Torgersen            36.6           17.8                185\n   8 │ Adelie    Torgersen            38.7           19.0                195\n   9 │ Adelie    Torgersen            42.5           20.7                197   ⋯\n  10 │ Adelie    Torgersen            34.4           18.4                184\n  11 │ Adelie    Torgersen            46.0           21.5                194\n                                                               2 columns omitted\n```\n\n\n:::\n:::\n\n:::\n\n## Arrange rows\n\nTo orders the rows of a data frame by the values of selected columns, we have `dplyr::arrange()` and `TidierData.@arrange()`. Note that both approaches arrange rows in an an ascending order and puts missing values last as defaults. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  arrange(island, desc(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           59.6          17                 230        6050\n 2 Gentoo  Biscoe           55.9          17                 228        5600\n 3 Gentoo  Biscoe           55.1          16                 230        5850\n 4 Gentoo  Biscoe           54.3          15.7               231        5650\n 5 Gentoo  Biscoe           53.4          15.8               219        5500\n 6 Gentoo  Biscoe           52.5          15.6               221        5450\n 7 Gentoo  Biscoe           52.2          17.1               228        5400\n 8 Gentoo  Biscoe           52.1          17                 230        5550\n 9 Gentoo  Biscoe           51.5          16.3               230        5500\n10 Gentoo  Biscoe           51.3          14.2               218        5300\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @arrange(island, desc(bill_length_mm))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n344×7 DataFrame\n Row │ species   island     bill_length_mm  bill_depth_mm  flipper_length_mm   ⋯\n     │ String15  String15   Float64?        Float64?       Int64?              ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Gentoo    Biscoe          missing        missing              missing   ⋯\n   2 │ Gentoo    Biscoe               59.6           17.0                230\n   3 │ Gentoo    Biscoe               55.9           17.0                228\n   4 │ Gentoo    Biscoe               55.1           16.0                230\n   5 │ Gentoo    Biscoe               54.3           15.7                231   ⋯\n  ⋮  │    ⋮          ⋮            ⋮               ⋮                ⋮           ⋱\n 340 │ Adelie    Torgersen            34.6           21.1                198\n 341 │ Adelie    Torgersen            34.6           17.2                189\n 342 │ Adelie    Torgersen            34.4           18.4                184\n 343 │ Adelie    Torgersen            34.1           18.1                193   ⋯\n 344 │ Adelie    Torgersen            33.5           19.0                190\n                                                  2 columns and 334 rows omitted\n```\n\n\n:::\n:::\n\n:::\n\n# Work with columns\n\n## Select columns\n\nSelecting a subset of columns works exactly the same with`dplyr::select()` and `TidierData.@select()`.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(bill_length_mm, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 2\n   bill_length_mm sex   \n            <dbl> <fct> \n 1           39.1 male  \n 2           39.5 female\n 3           40.3 female\n 4           NA   <NA>  \n 5           36.7 female\n 6           39.3 male  \n 7           38.9 female\n 8           39.2 male  \n 9           34.1 <NA>  \n10           42   <NA>  \n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @select(bill_length_mm, sex)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n344×2 DataFrame\n Row │ bill_length_mm  sex\n     │ Float64?        String7\n─────┼─────────────────────────\n   1 │           39.1  male\n   2 │           39.5  female\n   3 │           40.3  female\n   4 │      missing    missing\n   5 │           36.7  female\n  ⋮  │       ⋮            ⋮\n 340 │           55.8  male\n 341 │           43.5  female\n 342 │           49.6  male\n 343 │           50.8  male\n 344 │           50.2  female\n               334 rows omitted\n```\n\n\n:::\n:::\n\n:::\n\n## Rename columns\n\nRenaming columns also works exactly the same with `dplyr::rename()` and `TidierData.rename()`.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  rename(bill_length = bill_length_mm,\n         bill_depth = bill_depth_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length bill_depth flipper_length_mm body_mass_g sex   \n   <fct>   <fct>           <dbl>      <dbl>             <int>       <int> <fct> \n 1 Adelie  Torgersen        39.1       18.7               181        3750 male  \n 2 Adelie  Torgersen        39.5       17.4               186        3800 female\n 3 Adelie  Torgersen        40.3       18                 195        3250 female\n 4 Adelie  Torgersen        NA         NA                  NA          NA <NA>  \n 5 Adelie  Torgersen        36.7       19.3               193        3450 female\n 6 Adelie  Torgersen        39.3       20.6               190        3650 male  \n 7 Adelie  Torgersen        38.9       17.8               181        3625 female\n 8 Adelie  Torgersen        39.2       19.6               195        4675 male  \n 9 Adelie  Torgersen        34.1       18.1               193        3475 <NA>  \n10 Adelie  Torgersen        42         20.2               190        4250 <NA>  \n# ℹ 334 more rows\n# ℹ 1 more variable: year <int>\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @rename(bill_length = bill_length_mm,\n          bill_depth = bill_depth_mm)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n344×7 DataFrame\n Row │ species    island     bill_length  bill_depth  flipper_length_mm  body_ ⋯\n     │ String15   String15   Float64?     Float64?    Int64?             Int64 ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Adelie     Torgersen         39.1        18.7                181        ⋯\n   2 │ Adelie     Torgersen         39.5        17.4                186\n   3 │ Adelie     Torgersen         40.3        18.0                195\n   4 │ Adelie     Torgersen    missing     missing              missing      m\n   5 │ Adelie     Torgersen         36.7        19.3                193        ⋯\n  ⋮  │     ⋮          ⋮           ⋮           ⋮               ⋮                ⋱\n 340 │ Chinstrap  Dream             55.8        19.8                207\n 341 │ Chinstrap  Dream             43.5        18.1                202\n 342 │ Chinstrap  Dream             49.6        18.2                193\n 343 │ Chinstrap  Dream             50.8        19.0                210        ⋯\n 344 │ Chinstrap  Dream             50.2        18.7                198\n                                                  2 columns and 334 rows omitted\n```\n\n\n:::\n:::\n\n:::\n\n## Mutate columns\n\nTransforming existing columns or creating new ones is an essential part of data analysis. `dplyr::mutate()` and `TidierData.@mutate()` are the work horses for these tasks. Note that you have to split up variable assignments if you want to refer to a newly created variable in `TidierData`, while you can refer to the new variables in the same mutate block in `dplyr`.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  mutate(ones = 1,\n         bill_length = bill_length_mm / 10,\n         bill_length_squared = bill_length^2) |> \n  select(ones, bill_length_mm, bill_length, bill_length_squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 4\n    ones bill_length_mm bill_length bill_length_squared\n   <dbl>          <dbl>       <dbl>               <dbl>\n 1     1           39.1        3.91                15.3\n 2     1           39.5        3.95                15.6\n 3     1           40.3        4.03                16.2\n 4     1           NA         NA                   NA  \n 5     1           36.7        3.67                13.5\n 6     1           39.3        3.93                15.4\n 7     1           38.9        3.89                15.1\n 8     1           39.2        3.92                15.4\n 9     1           34.1        3.41                11.6\n10     1           42          4.2                 17.6\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @mutate(ones = 1,\n          bill_length = bill_length_mm / 10)\n  @mutate(bill_length_squared = bill_length^2)\n  @select(ones, bill_length_mm, bill_length, bill_length_squared)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n344×4 DataFrame\n Row │ ones   bill_length_mm  bill_length  bill_length_squared\n     │ Int64  Float64?        Float64?     Float64?\n─────┼─────────────────────────────────────────────────────────\n   1 │     1            39.1         3.91              15.2881\n   2 │     1            39.5         3.95              15.6025\n   3 │     1            40.3         4.03              16.2409\n   4 │     1       missing     missing            missing\n   5 │     1            36.7         3.67              13.4689\n  ⋮  │   ⋮          ⋮              ⋮                ⋮\n 340 │     1            55.8         5.58              31.1364\n 341 │     1            43.5         4.35              18.9225\n 342 │     1            49.6         4.96              24.6016\n 343 │     1            50.8         5.08              25.8064\n 344 │     1            50.2         5.02              25.2004\n                                               334 rows omitted\n```\n\n\n:::\n:::\n\n:::\n\n## Relocate columns\n\n`dplyr::relocate()` provides options to change the positions of columns in a data frame, using the same syntax as `dplyr::select()`. In addition, there are the options `.after` and `.before` to provide users with additional shortcuts. \n\nThe recommended way to relocate columns in `TidierData` is to use the `TidierData.@select()` method, but there are no options as in `dplyr::relocate()`. In fact, the safest way to consistently get the correct order of columns is to explicitly specify them. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  relocate(c(species, bill_length_mm), .before = sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   island    bill_depth_mm flipper_length_mm body_mass_g species bill_length_mm\n   <fct>             <dbl>             <int>       <int> <fct>            <dbl>\n 1 Torgersen          18.7               181        3750 Adelie            39.1\n 2 Torgersen          17.4               186        3800 Adelie            39.5\n 3 Torgersen          18                 195        3250 Adelie            40.3\n 4 Torgersen          NA                  NA          NA Adelie            NA  \n 5 Torgersen          19.3               193        3450 Adelie            36.7\n 6 Torgersen          20.6               190        3650 Adelie            39.3\n 7 Torgersen          17.8               181        3625 Adelie            38.9\n 8 Torgersen          19.6               195        4675 Adelie            39.2\n 9 Torgersen          18.1               193        3475 Adelie            34.1\n10 Torgersen          20.2               190        4250 Adelie            42  \n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @select(island, bill_depth_mm, flipper_length_mm, body_mass_g, \n          species, bill_length_mm, sex)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n344×7 DataFrame\n Row │ island     bill_depth_mm  flipper_length_mm  body_mass_g  species    bi ⋯\n     │ String15   Float64?       Int64?             Int64?       String15   Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Torgersen           18.7                181         3750  Adelie        ⋯\n   2 │ Torgersen           17.4                186         3800  Adelie\n   3 │ Torgersen           18.0                195         3250  Adelie\n   4 │ Torgersen      missing              missing      missing  Adelie\n   5 │ Torgersen           19.3                193         3450  Adelie        ⋯\n  ⋮  │     ⋮            ⋮                ⋮               ⋮           ⋮         ⋱\n 340 │ Dream               19.8                207         4000  Chinstrap\n 341 │ Dream               18.1                202         3400  Chinstrap\n 342 │ Dream               18.2                193         3775  Chinstrap\n 343 │ Dream               19.0                210         4100  Chinstrap     ⋯\n 344 │ Dream               18.7                198         3775  Chinstrap\n                                                  2 columns and 334 rows omitted\n```\n\n\n:::\n:::\n\n:::\n\n# Work with groups of rows\n\n## Simple summaries by group\n\nLet's suppose we want to compute summaries by groups such as means or medians. Both packages are virtually the same again: on the R side you have `dplyr::group_by()` and `dplyr::summarize()`, while on the Julia side you have `TidierData.@group_by()` and `TidierData.@summarize()`. Note that you have to include the `skipmissing()` wrapper in order to drop missing values in the `mean()` function. \n\nMoreover, `dplyr` also automatically arranges the results by the group, so the reproduce the results of `dplyr`, we need to add `TidierData.@arrange()` to the chain. \n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(island) |> \n  summarize(bill_depth_mean = mean(bill_depth_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  island    bill_depth_mean\n  <fct>               <dbl>\n1 Biscoe               15.9\n2 Dream                18.3\n3 Torgersen            18.4\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @group_by(island) \n  @summarize(bill_depth_mean = mean(skipmissing(bill_depth_mm)))\n  @arrange(island)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3×2 DataFrame\n Row │ island     bill_depth_mean\n     │ String15   Float64\n─────┼────────────────────────────\n   1 │ Biscoe             15.8749\n   2 │ Dream              18.3444\n   3 │ Torgersen          18.4294\n```\n\n\n:::\n:::\n\n:::\n\n## More complicated summaries by group\n\nTypically, you want to create multiple different summaries by groups. `dplyr` provides a lot of flexibility to create new variables on the fly, as does `TidierData`. For instance, we can pass expressions to them mean functions in order to create the share of female penguins per island in the summary statement.\n\n::: {.panel-tabset}\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(island) |> \n  summarize(count = n(),\n            bill_depth_mean = mean(bill_depth_mm, na.rm = TRUE),\n            flipper_length_median = median(flipper_length_mm, na.rm = TRUE),\n            body_mass_sd = sd(body_mass_g, na.rm = TRUE),\n            share_female = mean(sex == \"female\", na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  island   count bill_depth_mean flipper_length_median body_mass_sd share_female\n  <fct>    <int>           <dbl>                 <dbl>        <dbl>        <dbl>\n1 Biscoe     168            15.9                   214         783.        0.491\n2 Dream      124            18.3                   193         417.        0.496\n3 Torgers…    52            18.4                   191         445.        0.511\n```\n\n\n:::\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n@chain penguins begin\n  @group_by(island) \n  @summarize(count = n(),\n             bill_depth_mean = mean(skipmissing(bill_depth_mm)),\n             flipper_length_median = median(skipmissing(flipper_length_mm)),\n             body_mass_sd = std(skipmissing(body_mass_g)),\n             share_female = mean(skipmissing(sex == \"female\")))\n  @arrange(island)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3×6 DataFrame\n Row │ island     count  bill_depth_mean  flipper_length_median  body_mass_sd  ⋯\n     │ String15   Int64  Float64          Float64                Float64       ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Biscoe       168          15.8749                  214.0       782.856  ⋯\n   2 │ Dream        124          18.3444                  193.0       416.644\n   3 │ Torgersen     52          18.4294                  191.0       445.108\n                                                                1 column omitted\n```\n\n\n:::\n:::\n\n:::\n\n## Conclusion\n\nThis post highlights syntactic similarities and differences across R's `dplyr` and Julia's `TidierData` packages. The key difference is between pipes and chains: `dplyr` uses the pipe operator `|>` to chain functions, while `TidierData` uses the `@chain df begin ... end` syntax for piping a value through a series of transformation expressions. Nonetheless, the similarities are remarkable and demonstrate the flexibility of Julia to seemingly replicate the NSE capabilities of R. If you want to play around with Julia or some of its packages, I can highly recommend to take a shortcut using `TidierData`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}